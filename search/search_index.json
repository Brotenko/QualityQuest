{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quality Quest Introduction During this project a serious game is to be developed, in which an audience can interactively decide the course of an interesting and humorous story. At the beginning of the game the audience can choose from several player characters with different stats. The subsequent decisions made by voting influence the further course of the game, either by indirectly modifying stats through their decision and thus increasing the chances for random decisions to have a positive or negative outcome or by directly choosing which path of the story to take. The goal is to be invited to a prestigious workshop in Hawaii through good work. Motivation The image of the software developer is still strongly influenced by the clich\u00e9 of the nerd living in his parents' basement, doing whole projects on his own without feeling the need to interact with other people at all. However, due to the increasing focus on teamwork, readability and quality assurance, the reality is the exact opposite. Therefore the game aims to show the audience a contemporary picture of software development in a realistic and humorous way. The decisions made in the game are intended to demonstrate the skills required for this profession and show the positive effects of good practices in software development. Vision The game should have an appealing and clear presentation, and the audience should be able to participate easily via their smartphones and their laptops. However, the moderator should be able to continue the game on his own at any given time, or to pause the game if needed. The game should be able to be played through within twenty minutes. Context of project QualityQuest is developed within a software project of the University of Ulm in cooperation with NewTec GmbH, represented by Dr. Axel Newe, and shall be published as open source.","title":"Quality Quest"},{"location":"#quality-quest","text":"","title":"Quality Quest"},{"location":"#introduction","text":"During this project a serious game is to be developed, in which an audience can interactively decide the course of an interesting and humorous story. At the beginning of the game the audience can choose from several player characters with different stats. The subsequent decisions made by voting influence the further course of the game, either by indirectly modifying stats through their decision and thus increasing the chances for random decisions to have a positive or negative outcome or by directly choosing which path of the story to take. The goal is to be invited to a prestigious workshop in Hawaii through good work.","title":"Introduction"},{"location":"#motivation","text":"The image of the software developer is still strongly influenced by the clich\u00e9 of the nerd living in his parents' basement, doing whole projects on his own without feeling the need to interact with other people at all. However, due to the increasing focus on teamwork, readability and quality assurance, the reality is the exact opposite. Therefore the game aims to show the audience a contemporary picture of software development in a realistic and humorous way. The decisions made in the game are intended to demonstrate the skills required for this profession and show the positive effects of good practices in software development.","title":"Motivation"},{"location":"#vision","text":"The game should have an appealing and clear presentation, and the audience should be able to participate easily via their smartphones and their laptops. However, the moderator should be able to continue the game on his own at any given time, or to pause the game if needed. The game should be able to be played through within twenty minutes.","title":"Vision"},{"location":"#context-of-project","text":"QualityQuest is developed within a software project of the University of Ulm in cooperation with NewTec GmbH, represented by Dr. Axel Newe, and shall be published as open source.","title":"Context of project"},{"location":"architecture-diagrams/","text":"Architecture diagrams The diagrams below show the architectural structure of the different components of QualityQuest and how they communicate via well-defined interfaces. Class diagrams The class diagram shows the architectural structure of the individual components of QualityQuest and thus which classes are used in the implementation to logically implement the project. It also shows which interfaces the individual components use to communicate with each other. Since the StoryGraph is run and build locally on the Moderator-Client and the ServerLogic only has a forwarding function, a fallback is easily possible with only the moderator as decision-maker. If the ServerLogic can no longer be reached by the Moderator-Client, then this will be noticed by the lack of response to the messages of the Moderator-Client and the moderator will be informed together with the option to switch to Offline-Mode. Since the ServerLogic only transfers the voting results to the Moderator-Client, in case of a ServerLogic failure, only the functionality of online voting is lost, and the Moderator-Client can continue the game in an Offline-Session with no further drawbacks. In Offline-Mode, the Voting-Timer is deactivated and the moderator can select StoryFlowDecisions directly, while status checks are still performed in the background to inform the moderator in case the ServerLogic becomes available again. Server class diagrams The software components PlayerAudience-Client and ServerLogic are located on the same physical device, which is called Server. Since a separate cookie is created for each PlayerAudience-Client when connecting to the Online-Session, the communication between PlayerAudience-Clients and ServerLogic is managed by the PlayerAudienceClientManager class, which implements the Observer-pattern. The communication between ServerLogic and Moderator-Client is realized via a WebSocket connection over HTTPS, which is established after successful authentication. Component diagrams The class diagrams show the architectural structure of the individual components using interfaces/ports and subsystems. Component-Overview An overview of all components of QualityQuest and which interfaces exist between the individual components, or the user interfaces of the participants. The physical device Server contains the software component ServerLogic as the backend, while the PlayerAudience-Client component corresponds to the frontend. Since there are several instances of the PlayerAudience-Client, the communication between front-and backend is done via the Observer-pattern. The exchange between ServerLogic and Moderator-Client is realized via a WebSocket connection. PlayerAudience-Client The PlayerAudience-Client component consists of a subsystem GUI, which will allow the participant to interact with the game via the user interface, using HTML and JavaScript, and the subsystem Logic, which is responsible for interpreting inputs and exchanging data with the ServerLogic. ServerLogic The ServerLogic component consists of a subsystem for the Message Management, which interprets the determined results, and a MainLogic subsystem. The MainLogic subsystem interacts with the PlayerAudience-Client, providing the voting options for it and evaluating the submitted votes. Connected to this is the subsystem Message Management, which prepares the received data and converts the results into a JSON for further communication. Moderator-Client The component Moderator-Client consists of a subsystem GUI, which, based on Unity, provides a user interface to the moderator for interacting and presenting the game. The subsystem Logic manages the progress in the StoryGraph, the influence of PlayerCharacterStatusValues on StoryFlowDecisions as well as the communication to the component ServerLogic via the WebSocket.","title":"Architecture diagrams"},{"location":"architecture-diagrams/#architecture-diagrams","text":"The diagrams below show the architectural structure of the different components of QualityQuest and how they communicate via well-defined interfaces.","title":"Architecture diagrams"},{"location":"architecture-diagrams/#class-diagrams","text":"The class diagram shows the architectural structure of the individual components of QualityQuest and thus which classes are used in the implementation to logically implement the project. It also shows which interfaces the individual components use to communicate with each other. Since the StoryGraph is run and build locally on the Moderator-Client and the ServerLogic only has a forwarding function, a fallback is easily possible with only the moderator as decision-maker. If the ServerLogic can no longer be reached by the Moderator-Client, then this will be noticed by the lack of response to the messages of the Moderator-Client and the moderator will be informed together with the option to switch to Offline-Mode. Since the ServerLogic only transfers the voting results to the Moderator-Client, in case of a ServerLogic failure, only the functionality of online voting is lost, and the Moderator-Client can continue the game in an Offline-Session with no further drawbacks. In Offline-Mode, the Voting-Timer is deactivated and the moderator can select StoryFlowDecisions directly, while status checks are still performed in the background to inform the moderator in case the ServerLogic becomes available again.","title":"Class diagrams"},{"location":"architecture-diagrams/#server-class-diagrams","text":"The software components PlayerAudience-Client and ServerLogic are located on the same physical device, which is called Server. Since a separate cookie is created for each PlayerAudience-Client when connecting to the Online-Session, the communication between PlayerAudience-Clients and ServerLogic is managed by the PlayerAudienceClientManager class, which implements the Observer-pattern. The communication between ServerLogic and Moderator-Client is realized via a WebSocket connection over HTTPS, which is established after successful authentication.","title":"Server class diagrams"},{"location":"architecture-diagrams/#component-diagrams","text":"The class diagrams show the architectural structure of the individual components using interfaces/ports and subsystems.","title":"Component diagrams"},{"location":"architecture-diagrams/#component-overview","text":"An overview of all components of QualityQuest and which interfaces exist between the individual components, or the user interfaces of the participants. The physical device Server contains the software component ServerLogic as the backend, while the PlayerAudience-Client component corresponds to the frontend. Since there are several instances of the PlayerAudience-Client, the communication between front-and backend is done via the Observer-pattern. The exchange between ServerLogic and Moderator-Client is realized via a WebSocket connection.","title":"Component-Overview"},{"location":"architecture-diagrams/#playeraudience-client","text":"The PlayerAudience-Client component consists of a subsystem GUI, which will allow the participant to interact with the game via the user interface, using HTML and JavaScript, and the subsystem Logic, which is responsible for interpreting inputs and exchanging data with the ServerLogic.","title":"PlayerAudience-Client"},{"location":"architecture-diagrams/#serverlogic","text":"The ServerLogic component consists of a subsystem for the Message Management, which interprets the determined results, and a MainLogic subsystem. The MainLogic subsystem interacts with the PlayerAudience-Client, providing the voting options for it and evaluating the submitted votes. Connected to this is the subsystem Message Management, which prepares the received data and converts the results into a JSON for further communication.","title":"ServerLogic"},{"location":"architecture-diagrams/#moderator-client","text":"The component Moderator-Client consists of a subsystem GUI, which, based on Unity, provides a user interface to the moderator for interacting and presenting the game. The subsystem Logic manages the progress in the StoryGraph, the influence of PlayerCharacterStatusValues on StoryFlowDecisions as well as the communication to the component ServerLogic via the WebSocket.","title":"Moderator-Client"},{"location":"changehistory/","text":"Change history The change history is a chronologically ordered list of all changes between different documentation versions. The different versions are listed together with the release date and a link to the changelog of the version. Modification types Type Description + An addition to a document. - A removal from a document. * An alteration of something pre-existing. Examples Type Description + Section that has the change in it: What has been changed: What exactly has been done. - Change History: Example: Removed an example. * Glossary: Moderator-Client: Clarification regarding server backup. Table of contents Version Quick Description Date Link 0.1.0 Architecture design 2020-10-09 Link 0.1.1 First revision of the architecture design 2020-10-27 Link 0.1.2 Second revision of the architecture design 2020-11-12 Link 0.2.0 Component design 2020-11-17 Link 0.2.1 First revision of the component design 2020-11-26 Link 0.2.2 Second revision of the component design TBA Link Version 0.2.2 - Second revision of the component design Type Description + Used Tools: Visual Studio 2019: Added used tool. + Used Tools: Adobe XD: Added used tool. + Used Libraries: Microsoft.NET.Test.Sdk: Added used library. + Used Libraries: MSTest.TestAdapter: Added used library. + Used Libraries: MSTest.TestFramework: Added used library. + Used Libraries: System.Drawing.Common: Added used library. + Used Libraries: QRCoder: Added used library. + Used Libraries: coverlet.collector: Added used library. * Non-functional Requirements: NFR2: Updated description. * Non-functional Requirements: NFR6: Updated description. * Non-functional Requirements: NFR18: Updated description. + Functional Requirements: FR54: Added requirement \"SessionKey length\". * Network Protocol: MessageType Enum: Renamed from \"MessageTypeEnum\" to \"MessageType Enum\". * Network Protocol: ErrorType Enum: Renamed from \"ErrorTypeEnum\" to \"ErrorType Enum\". * Network Protocol: Network protocol: Renamed occurrences of \"MessageTypeEnum\" to \"MessageType\". * Network Protocol: Network protocol: Renamed occurrences of \"ErrorTypeEnum\" to \"ErrorType\". * Network Protocol: Network protocol: All messages now end on \"[...]Message\". * Network Protocol: Network protocol: All fields and methods are now uppercase. + Network Protocol: RequestOpenSessionMessage: Added description for the field \"Password\". * Network Protocol: MessageContainer: Updated type of \"CreationDate\" to \"DateTime\". * Network Protocol: SessionOpenedMessage: Updated type of \"DirectURL\" to \"Uri\". * Network Protocol: VotingEndedMessage: Updated type of \"WinningOption\" to \"Guid\". * Network Protocol: ErrorMessage: Renamed field \"ErrorType\" to \"ErrorMessageType\". * Network Protocol: ErrorMessage: Renamed field \"ErrorMessage\" to \"ErrorMessageText\". Version 0.2.1 - First revision of the component design Type Description * Quality Quest:_ Quality Quest: Updated all texts. * Table of contents: Table of contents: Extension and reordering of the table of contents. * Glossary: Actors and Roles: Updated description. * Glossary: Expertise: Updated description. * Glossary: Glossary: Updated all entries to have the new style. * Glossary: Moderator: Updated description. * Glossary: Server: Updated description. * Glossary: Moderator-Client: Updated description. * Glossary: PlayerAudience-Client: Updated description. * Glossary: Client: Updated description. * Glossary: StoryFlowDecision: Updated description. * Glossary: Network protocol: Updated description. * Glossary: Online-Mode: Updated description. * Glossary: Offline-Mode: Updated description. * Glossary: Online voting: Updated description. * Glossary: PauseButton: Updated description and changed name from \"Pause-Button\" to \"PauseButton\". + Glossary: StoryGraph: Added new entry. * Functional Requirements: FR1: Updated description. * Functional Requirements: FR3: Updated description. * Functional Requirements: FR11: Updated description and explanation. * Functional Requirements: FR14: Updated description. * Functional Requirements: FR15: Updated description. * Functional Requirements: FR16: Updated description. * Functional Requirements: FR18: Updated description. * Functional Requirements: FR19: Updated description. * Functional Requirements: FR20: Updated description. * Functional Requirements: FR23: Updated description. * Functional Requirements: FR31: Updated description and changed name from \"Communication protocol violation\" to \"Network protocol violation\". * Functional Requirements: FR33: Updated description. * Functional Requirements: FR35: Updated description. * Functional Requirements: FR40: Updated description. * Non-functional Requirements: NFR8: Changed name from \"Target PlayerAudience\" to \"Target audience\". * Requirements: Requirements: Updated all entries to have the new style. * Requirements: Requirements: Fixed typos. * Use-case diagrams: PlayerAudience-Client: Updated description. * Use-case diagrams: ServerLogic: Changed name from \"Server\" to \"ServerLogic\". * Use-case diagrams: Start application: Updated description and changed name from \"Start Application\" to \"Start application\". * Use-case diagrams: Play game: Updated description and changed name from \"Play Game\" to \"Play game\". * Use-case diagrams: End application: Updated description and changed name from \"End Application\" to \"End application\". * Architecture diagrams: Architecture diagrams: Updated description. * Architecture diagrams: Class diagrams: Updated description. * Architecture diagrams: Moderator-Client: Updated description. * Architecture diagrams: Server class diagrams: Updated description. * Architecture diagrams: Component-Overview: Updated description. * Architecture diagrams: PlayerAudience-Client: Updated description. * Architecture diagrams: Component diagrams: Updated description. * Architecture diagrams: ServerLogic: Updated description and changed name from \"Server\" to \"ServerLogic\". + StoryFlow: StoryFlow overview: Added new section. * StoryFlow: Detailed StoryFlow diagrams: Changed name from \"Detailed-StoryFlow diagrams\" to \"Detailed StoryFlow diagrams\". * StoryFlow: StoryFlow overview: Updated description. * StoryFlow: Detailed StoryFlow diagrams: Updated description. * Change history: Change history: Fixed typos. + StoryFlow: StoryFlowDecision 1: Added description. + StoryFlow: StoryFlowDecision 2: Added description. + StoryFlow: StoryFlowDecision 3: Added description. + StoryFlow: StoryFlowDecision 3: Added description. + StoryFlow: StoryFlowDecision 4: Added description. + StoryFlow: StoryFlowDecision 6: Added description. + StoryFlow: StoryFlowDecision 6: Added description. + StoryFlow: StoryFlowDecision 7: Added description. + StoryFlow: StoryFlowDecision 8: Added description. + StoryFlow: StoryFlowDecision 9: Added description. + StoryFlow: StoryFlowDecision 10: Added description. + StoryFlow: StoryFlowDecision 11: Added description. + StoryFlow: StoryFlowDecision 12: Added description. + StoryFlow: StoryFlowDecision 13: Added description. + StoryFlow: StoryFlowDecision 14: Added description. + StoryFlow: StoryFlowDecision 15: Added description. * Architecture diagrams: ServerLogic: Updated diagram: Changed \"Websocket\" to \"WebSocket\". * Architecture diagrams: Moderator-Client: Updated diagram: Changed \"Websocket\" to \"WebSocket\". * Architecture diagrams: Component-Overview: Updated diagram: Changed \"Websocket\" to \"WebSocket\". * Architecture diagrams: Class diagrams: Updated diagram: Changed \"websocket\" to \"webSocket\". * Use-case diagrams: PlayerAudience-Client: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: ServerLogic: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: Moderator-Client: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: Play game: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: End application: Updated diagram: Changed \"Server\" to \"ServerLogic\". Version 0.2.0 - Component design Type Description + Class diagrams: Server class diagram: Added a joined class diagram for PlayerAudience-Client and Server, along with a description. * Class diagrams: Class diagrams: Updated class diagram with the new Server diagram * Functional Requirements: Edited term \"Server\" to \"ServerLogic\": Was changed in FR24, FR25, FR26, FR27, FR28 and FR29. * Non-functional Requirements: Edited term \"Server\" to \"ServerLogic\": Was changed in NFR20 and NFR21. + Glossary: ServerLogic: Added new entry. * Glossary: Server: Changed description. * Component diagrams: All component diagrams: Updated diagrams and descriptions. + StoryFlow diagram: Detailed StoryFlow Diagrams: Added detailed StoryFlow diagrams for every StoryFlowDecision. + Network Protocol: Network protocol: Added the network protocol to the documentation. - Glossary: Voting-Tool: Removed entry. * Glossary: ServerLogic: Changed description to specify that the ServerLogic is responsible for realising voting. + Glossary: Online-Mode: Added new entry. * Glossary: Online voting: Changed description and changed term from \"OnlineVoting\" to \"Online voting\". * Glossary: Network protocol: Changed term from \"Communication protocol\" to \"Network protocol\". * Glossary: Online-Session: Changed description to specify the session being online and changed term from \"Session\" to \"Online-Session\". + Glossary: Offline-Session: Added new entry. + Glossary: Globally Unique Identifier (GUID): Added new entry. + Glossary: Offline-Mode: Added new entry. + Used Plugins: Code Spell Checker: Added used plugin. * Functional Requirements: FR25: Changed the reaction time from \"10 seconds\" to \"5 seconds\". * Functional Requirements: FR26: Changed \"UUID\" to \"GUID\". * Functional Requirements: FR28: Changed \"client\" to \"PlayerAudience-Client\". * Functional Requirements: FR28: Changed name to \"PlayerAudience-Client GUID\" and changed the description accordingly. * Functional Requirements: FR31: Changed \"UUID\" to \"GUID\". + Functional Requirements: FR32: Added requirement \"Unique voting option identifier\". + Functional Requirements: FR33: Added requirement \"Game-relevant ServerLogic logging\". + Functional Requirements: FR34: Added requirement \"General ServerLogic logging\". + Functional Requirements: FR35: Added requirement \"ServerLogic log deletion\". + Functional Requirements: FR36: Added requirement \"ServerLogic access-password\". + Functional Requirements: FR37: Added requirement \"Hashing of integral data\". + Functional Requirements: FR38: Added requirement \"Online-Mode\". + Functional Requirements: FR39: Added requirement \"Online-Mode flag\". + Functional Requirements: FR40: Added requirement \"Moderator-Client GUID\". + Functional Requirements: FR41: Added requirement \"PlayerAudience-Client count\". + Functional Requirements: FR42: Added requirement \"PlayerAudience-Client count live update\". + Functional Requirements: FR43: Added requirement \"Online-Session permanence\". + Functional Requirements: FR44: Added requirement \"Switch between Moderator-Clients\". + Functional Requirements: FR45: Added requirement \"Voting-Timer stop on pause\". + Functional Requirements: FR46: Added requirement \"Communication during pauses\". + Functional Requirements: FR47: Added requirement \"PlayerAudience connection method\". + Functional Requirements: FR48: Added requirement \"PlayerAudience connection option\". + Functional Requirements: FR49: Added requirement \"Additional PlayerAudience connection options\". + Functional Requirements: FR50: Added requirement \"Pause menu\". + Functional Requirements: FR51: Added requirement \"Pause menu contents\". + Functional Requirements: FR52: Added requirement \"Index hashing procedure\". + Functional Requirements: FR53: Added requirement \"Cryptographic hashing procedure\". + Non-functional Requirements: NFR23: Added requirement \"Communication security\". + Non-functional Requirements: NFR24: Added requirement \"Postgame statistics\". + Non-functional Requirements: NFR25: Added requirement \"Postgame statistic contents\". * Change history: Change history: Fixed typos. * Glossary: Glossary: Fixed typos. * Requirements: Requirements: Fixed typos. * Table of content: Table of content: Fixed typos. * Used tools, plugins and libraries: Used tools, plugins and libraries: Fixed typos. * Class diagrams: Class diagrams: Updated class diagrams with GUIDs and further Adaptions. Version 0.1.2 - Second revision of the architecture design Type Description * Change history: Table of contents: Fixed the links to properly work when exported to HTML/CSS. * Glossary: DiceRandomness: Changed \"die\" to \"dice\" for clarification. * Functional Requirements: Offline-Mode: Update the description to say \"shall\" instead of \"must\". * Used Plugins: Markdown All in One: Fixed typo in description. * Used Plugins: PlantUML: Fixed typo in description. + Glossary: Session: Added new term. * Change history: Change history: Renamed change history versions descriptors. * Use-Case diagrams: Moderator-Client: Updated all Moderator-Client use-case diagrams and descriptions. Version 0.1.1 - First revision of the architecture design This is the revised version of the Technical Specifications according to the feedback provided by the customer. Type Description * Glossary: Moderator-Client: Clarification regarding server backup. * Glossary: StoryFlowDecision: Clarification regarding server backup. * Glossary: DiceRandomness: Clarified that the die is six-sided. * Glossary: Voting-Timer: Updated voting time from \"60 seconds\" to \"30 seconds\". * Functional Requirements: Stand-alone game: Moved to non-functional requirements. * Functional Requirements: Game language options: Changed priority from \"-\" to \"0\". * Functional Requirements: Participation of a larger PlayerAudience: Clarification regarding server backup. * Functional Requirements: Character status values: Resolved redundancy with requirement \"Character levelling\". * Functional Requirements: Selecting a character: Concrete selection of characters added. * Functional Requirements: Presentation of character status values: Fixed description and explanation. * Functional Requirements: Character levelling: Resolved redundancy with requirement \"Selecting a character\" and specified levelling up and down. * Functional Requirements: Programming language: Moved to non-functional requirements. * Functional Requirements: Development environment: Moved to non-functional requirements. - Functional Requirements: Usage of game engines: Requirement removed. * Functional Requirements: Usage of online voting solutions: Moved to non-functional requirements. * Functional Requirements: Pause Game: Division into functional requirements \"Pause Game\" and \"PauseButton location\". + Functional Requirements: PauseButton location: Added requirement. - Functional Requirements: Connection Setup: Removed requirement. + Functional Requirements: Amount of supported connections: Added requirement. + Functional Requirements: Exclusive Moderator-Client connection: Added requirement. + Functional Requirements: Moderator game control: Added requirement. * Functional Requirements: Connection Timeout: Clarification regarding communication participants and technical terminology. * Functional Requirements: Server connection loss: Clarification regarding \"system\" being the \"server\". * Functional Requirements: Unique User Identifier (UUID): Specified the UUID. Changed \"participant\" to \"client\". * Functional Requirements: Offline-Mode: Restructured the structure of the requirement. Clarified that the Moderator should \"always\" have the option to continue the game in Offline-Mode. Division into functional requirements \"Offline-Mode\" and \"Offline-Mode transition\". + Functional Requirements: Offline-Mode transition: Added requirement. * Functional Requirements: Game Engine: Moved to non-functional requirements. Resolved redundancy with requirement \"Game Engine\". * Functional Requirements: Communication protocol: Moved to glossary. * Non-functional Requirements: Adherence to Clean Code Principles: Changed priority from \"0\" to \"+\" and updated the description accordingly. * Non-functional Requirements: Type of delivery: Fixed typo in description. Changed \"DOCX\" to \"HTML\". * Requirements: Functional Requirements: Changed Id from \"FA\" to \"FR\". * Requirements: Non-functional Requirements: Changed Id from \"QA\" to \"NFR\". * Component diagrams: Component diagrams: Updated notation and changed inconsistent interface labels. * Component diagrams: Component diagrams: Updated descriptions for all component diagrams. + Used plugins: Live Share: Added used plugin. * Use-case diagrams: Moderator-Client: Division into \"Start Application\", \"Play Game\" and \"End Application\" diagrams. - StoryFlow diagram: StoryFlow diagram: Removed obsolete StoryFlow diagram. * Non-functional Requirements: Usage of online voting solutions:\" Updated the description to clarify that the voting tool will be made by the team. Version 0.1.0 - Architecture design This is the initial version of the Technical Specifications and thus has no changelog. The next version, which will focus on the component/detailed design, will be the first version with a changelog.","title":"Change history"},{"location":"changehistory/#change-history","text":"The change history is a chronologically ordered list of all changes between different documentation versions. The different versions are listed together with the release date and a link to the changelog of the version.","title":"Change history"},{"location":"changehistory/#modification-types","text":"Type Description + An addition to a document. - A removal from a document. * An alteration of something pre-existing.","title":"Modification types"},{"location":"changehistory/#examples","text":"Type Description + Section that has the change in it: What has been changed: What exactly has been done. - Change History: Example: Removed an example. * Glossary: Moderator-Client: Clarification regarding server backup.","title":"Examples"},{"location":"changehistory/#table-of-contents","text":"Version Quick Description Date Link 0.1.0 Architecture design 2020-10-09 Link 0.1.1 First revision of the architecture design 2020-10-27 Link 0.1.2 Second revision of the architecture design 2020-11-12 Link 0.2.0 Component design 2020-11-17 Link 0.2.1 First revision of the component design 2020-11-26 Link 0.2.2 Second revision of the component design TBA Link","title":"Table of contents"},{"location":"changehistory/#version-022-second-revision-of-the-component-design","text":"Type Description + Used Tools: Visual Studio 2019: Added used tool. + Used Tools: Adobe XD: Added used tool. + Used Libraries: Microsoft.NET.Test.Sdk: Added used library. + Used Libraries: MSTest.TestAdapter: Added used library. + Used Libraries: MSTest.TestFramework: Added used library. + Used Libraries: System.Drawing.Common: Added used library. + Used Libraries: QRCoder: Added used library. + Used Libraries: coverlet.collector: Added used library. * Non-functional Requirements: NFR2: Updated description. * Non-functional Requirements: NFR6: Updated description. * Non-functional Requirements: NFR18: Updated description. + Functional Requirements: FR54: Added requirement \"SessionKey length\". * Network Protocol: MessageType Enum: Renamed from \"MessageTypeEnum\" to \"MessageType Enum\". * Network Protocol: ErrorType Enum: Renamed from \"ErrorTypeEnum\" to \"ErrorType Enum\". * Network Protocol: Network protocol: Renamed occurrences of \"MessageTypeEnum\" to \"MessageType\". * Network Protocol: Network protocol: Renamed occurrences of \"ErrorTypeEnum\" to \"ErrorType\". * Network Protocol: Network protocol: All messages now end on \"[...]Message\". * Network Protocol: Network protocol: All fields and methods are now uppercase. + Network Protocol: RequestOpenSessionMessage: Added description for the field \"Password\". * Network Protocol: MessageContainer: Updated type of \"CreationDate\" to \"DateTime\". * Network Protocol: SessionOpenedMessage: Updated type of \"DirectURL\" to \"Uri\". * Network Protocol: VotingEndedMessage: Updated type of \"WinningOption\" to \"Guid\". * Network Protocol: ErrorMessage: Renamed field \"ErrorType\" to \"ErrorMessageType\". * Network Protocol: ErrorMessage: Renamed field \"ErrorMessage\" to \"ErrorMessageText\".","title":"Version 0.2.2 - Second revision of the component design"},{"location":"changehistory/#version-021-first-revision-of-the-component-design","text":"Type Description * Quality Quest:_ Quality Quest: Updated all texts. * Table of contents: Table of contents: Extension and reordering of the table of contents. * Glossary: Actors and Roles: Updated description. * Glossary: Expertise: Updated description. * Glossary: Glossary: Updated all entries to have the new style. * Glossary: Moderator: Updated description. * Glossary: Server: Updated description. * Glossary: Moderator-Client: Updated description. * Glossary: PlayerAudience-Client: Updated description. * Glossary: Client: Updated description. * Glossary: StoryFlowDecision: Updated description. * Glossary: Network protocol: Updated description. * Glossary: Online-Mode: Updated description. * Glossary: Offline-Mode: Updated description. * Glossary: Online voting: Updated description. * Glossary: PauseButton: Updated description and changed name from \"Pause-Button\" to \"PauseButton\". + Glossary: StoryGraph: Added new entry. * Functional Requirements: FR1: Updated description. * Functional Requirements: FR3: Updated description. * Functional Requirements: FR11: Updated description and explanation. * Functional Requirements: FR14: Updated description. * Functional Requirements: FR15: Updated description. * Functional Requirements: FR16: Updated description. * Functional Requirements: FR18: Updated description. * Functional Requirements: FR19: Updated description. * Functional Requirements: FR20: Updated description. * Functional Requirements: FR23: Updated description. * Functional Requirements: FR31: Updated description and changed name from \"Communication protocol violation\" to \"Network protocol violation\". * Functional Requirements: FR33: Updated description. * Functional Requirements: FR35: Updated description. * Functional Requirements: FR40: Updated description. * Non-functional Requirements: NFR8: Changed name from \"Target PlayerAudience\" to \"Target audience\". * Requirements: Requirements: Updated all entries to have the new style. * Requirements: Requirements: Fixed typos. * Use-case diagrams: PlayerAudience-Client: Updated description. * Use-case diagrams: ServerLogic: Changed name from \"Server\" to \"ServerLogic\". * Use-case diagrams: Start application: Updated description and changed name from \"Start Application\" to \"Start application\". * Use-case diagrams: Play game: Updated description and changed name from \"Play Game\" to \"Play game\". * Use-case diagrams: End application: Updated description and changed name from \"End Application\" to \"End application\". * Architecture diagrams: Architecture diagrams: Updated description. * Architecture diagrams: Class diagrams: Updated description. * Architecture diagrams: Moderator-Client: Updated description. * Architecture diagrams: Server class diagrams: Updated description. * Architecture diagrams: Component-Overview: Updated description. * Architecture diagrams: PlayerAudience-Client: Updated description. * Architecture diagrams: Component diagrams: Updated description. * Architecture diagrams: ServerLogic: Updated description and changed name from \"Server\" to \"ServerLogic\". + StoryFlow: StoryFlow overview: Added new section. * StoryFlow: Detailed StoryFlow diagrams: Changed name from \"Detailed-StoryFlow diagrams\" to \"Detailed StoryFlow diagrams\". * StoryFlow: StoryFlow overview: Updated description. * StoryFlow: Detailed StoryFlow diagrams: Updated description. * Change history: Change history: Fixed typos. + StoryFlow: StoryFlowDecision 1: Added description. + StoryFlow: StoryFlowDecision 2: Added description. + StoryFlow: StoryFlowDecision 3: Added description. + StoryFlow: StoryFlowDecision 3: Added description. + StoryFlow: StoryFlowDecision 4: Added description. + StoryFlow: StoryFlowDecision 6: Added description. + StoryFlow: StoryFlowDecision 6: Added description. + StoryFlow: StoryFlowDecision 7: Added description. + StoryFlow: StoryFlowDecision 8: Added description. + StoryFlow: StoryFlowDecision 9: Added description. + StoryFlow: StoryFlowDecision 10: Added description. + StoryFlow: StoryFlowDecision 11: Added description. + StoryFlow: StoryFlowDecision 12: Added description. + StoryFlow: StoryFlowDecision 13: Added description. + StoryFlow: StoryFlowDecision 14: Added description. + StoryFlow: StoryFlowDecision 15: Added description. * Architecture diagrams: ServerLogic: Updated diagram: Changed \"Websocket\" to \"WebSocket\". * Architecture diagrams: Moderator-Client: Updated diagram: Changed \"Websocket\" to \"WebSocket\". * Architecture diagrams: Component-Overview: Updated diagram: Changed \"Websocket\" to \"WebSocket\". * Architecture diagrams: Class diagrams: Updated diagram: Changed \"websocket\" to \"webSocket\". * Use-case diagrams: PlayerAudience-Client: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: ServerLogic: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: Moderator-Client: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: Play game: Updated diagram: Changed \"Server\" to \"ServerLogic\". * Use-case diagrams: End application: Updated diagram: Changed \"Server\" to \"ServerLogic\".","title":"Version 0.2.1 - First revision of the component design"},{"location":"changehistory/#version-020-component-design","text":"Type Description + Class diagrams: Server class diagram: Added a joined class diagram for PlayerAudience-Client and Server, along with a description. * Class diagrams: Class diagrams: Updated class diagram with the new Server diagram * Functional Requirements: Edited term \"Server\" to \"ServerLogic\": Was changed in FR24, FR25, FR26, FR27, FR28 and FR29. * Non-functional Requirements: Edited term \"Server\" to \"ServerLogic\": Was changed in NFR20 and NFR21. + Glossary: ServerLogic: Added new entry. * Glossary: Server: Changed description. * Component diagrams: All component diagrams: Updated diagrams and descriptions. + StoryFlow diagram: Detailed StoryFlow Diagrams: Added detailed StoryFlow diagrams for every StoryFlowDecision. + Network Protocol: Network protocol: Added the network protocol to the documentation. - Glossary: Voting-Tool: Removed entry. * Glossary: ServerLogic: Changed description to specify that the ServerLogic is responsible for realising voting. + Glossary: Online-Mode: Added new entry. * Glossary: Online voting: Changed description and changed term from \"OnlineVoting\" to \"Online voting\". * Glossary: Network protocol: Changed term from \"Communication protocol\" to \"Network protocol\". * Glossary: Online-Session: Changed description to specify the session being online and changed term from \"Session\" to \"Online-Session\". + Glossary: Offline-Session: Added new entry. + Glossary: Globally Unique Identifier (GUID): Added new entry. + Glossary: Offline-Mode: Added new entry. + Used Plugins: Code Spell Checker: Added used plugin. * Functional Requirements: FR25: Changed the reaction time from \"10 seconds\" to \"5 seconds\". * Functional Requirements: FR26: Changed \"UUID\" to \"GUID\". * Functional Requirements: FR28: Changed \"client\" to \"PlayerAudience-Client\". * Functional Requirements: FR28: Changed name to \"PlayerAudience-Client GUID\" and changed the description accordingly. * Functional Requirements: FR31: Changed \"UUID\" to \"GUID\". + Functional Requirements: FR32: Added requirement \"Unique voting option identifier\". + Functional Requirements: FR33: Added requirement \"Game-relevant ServerLogic logging\". + Functional Requirements: FR34: Added requirement \"General ServerLogic logging\". + Functional Requirements: FR35: Added requirement \"ServerLogic log deletion\". + Functional Requirements: FR36: Added requirement \"ServerLogic access-password\". + Functional Requirements: FR37: Added requirement \"Hashing of integral data\". + Functional Requirements: FR38: Added requirement \"Online-Mode\". + Functional Requirements: FR39: Added requirement \"Online-Mode flag\". + Functional Requirements: FR40: Added requirement \"Moderator-Client GUID\". + Functional Requirements: FR41: Added requirement \"PlayerAudience-Client count\". + Functional Requirements: FR42: Added requirement \"PlayerAudience-Client count live update\". + Functional Requirements: FR43: Added requirement \"Online-Session permanence\". + Functional Requirements: FR44: Added requirement \"Switch between Moderator-Clients\". + Functional Requirements: FR45: Added requirement \"Voting-Timer stop on pause\". + Functional Requirements: FR46: Added requirement \"Communication during pauses\". + Functional Requirements: FR47: Added requirement \"PlayerAudience connection method\". + Functional Requirements: FR48: Added requirement \"PlayerAudience connection option\". + Functional Requirements: FR49: Added requirement \"Additional PlayerAudience connection options\". + Functional Requirements: FR50: Added requirement \"Pause menu\". + Functional Requirements: FR51: Added requirement \"Pause menu contents\". + Functional Requirements: FR52: Added requirement \"Index hashing procedure\". + Functional Requirements: FR53: Added requirement \"Cryptographic hashing procedure\". + Non-functional Requirements: NFR23: Added requirement \"Communication security\". + Non-functional Requirements: NFR24: Added requirement \"Postgame statistics\". + Non-functional Requirements: NFR25: Added requirement \"Postgame statistic contents\". * Change history: Change history: Fixed typos. * Glossary: Glossary: Fixed typos. * Requirements: Requirements: Fixed typos. * Table of content: Table of content: Fixed typos. * Used tools, plugins and libraries: Used tools, plugins and libraries: Fixed typos. * Class diagrams: Class diagrams: Updated class diagrams with GUIDs and further Adaptions.","title":"Version 0.2.0 - Component design"},{"location":"changehistory/#version-012-second-revision-of-the-architecture-design","text":"Type Description * Change history: Table of contents: Fixed the links to properly work when exported to HTML/CSS. * Glossary: DiceRandomness: Changed \"die\" to \"dice\" for clarification. * Functional Requirements: Offline-Mode: Update the description to say \"shall\" instead of \"must\". * Used Plugins: Markdown All in One: Fixed typo in description. * Used Plugins: PlantUML: Fixed typo in description. + Glossary: Session: Added new term. * Change history: Change history: Renamed change history versions descriptors. * Use-Case diagrams: Moderator-Client: Updated all Moderator-Client use-case diagrams and descriptions.","title":"Version 0.1.2 - Second revision of the architecture design"},{"location":"changehistory/#version-011-first-revision-of-the-architecture-design","text":"This is the revised version of the Technical Specifications according to the feedback provided by the customer. Type Description * Glossary: Moderator-Client: Clarification regarding server backup. * Glossary: StoryFlowDecision: Clarification regarding server backup. * Glossary: DiceRandomness: Clarified that the die is six-sided. * Glossary: Voting-Timer: Updated voting time from \"60 seconds\" to \"30 seconds\". * Functional Requirements: Stand-alone game: Moved to non-functional requirements. * Functional Requirements: Game language options: Changed priority from \"-\" to \"0\". * Functional Requirements: Participation of a larger PlayerAudience: Clarification regarding server backup. * Functional Requirements: Character status values: Resolved redundancy with requirement \"Character levelling\". * Functional Requirements: Selecting a character: Concrete selection of characters added. * Functional Requirements: Presentation of character status values: Fixed description and explanation. * Functional Requirements: Character levelling: Resolved redundancy with requirement \"Selecting a character\" and specified levelling up and down. * Functional Requirements: Programming language: Moved to non-functional requirements. * Functional Requirements: Development environment: Moved to non-functional requirements. - Functional Requirements: Usage of game engines: Requirement removed. * Functional Requirements: Usage of online voting solutions: Moved to non-functional requirements. * Functional Requirements: Pause Game: Division into functional requirements \"Pause Game\" and \"PauseButton location\". + Functional Requirements: PauseButton location: Added requirement. - Functional Requirements: Connection Setup: Removed requirement. + Functional Requirements: Amount of supported connections: Added requirement. + Functional Requirements: Exclusive Moderator-Client connection: Added requirement. + Functional Requirements: Moderator game control: Added requirement. * Functional Requirements: Connection Timeout: Clarification regarding communication participants and technical terminology. * Functional Requirements: Server connection loss: Clarification regarding \"system\" being the \"server\". * Functional Requirements: Unique User Identifier (UUID): Specified the UUID. Changed \"participant\" to \"client\". * Functional Requirements: Offline-Mode: Restructured the structure of the requirement. Clarified that the Moderator should \"always\" have the option to continue the game in Offline-Mode. Division into functional requirements \"Offline-Mode\" and \"Offline-Mode transition\". + Functional Requirements: Offline-Mode transition: Added requirement. * Functional Requirements: Game Engine: Moved to non-functional requirements. Resolved redundancy with requirement \"Game Engine\". * Functional Requirements: Communication protocol: Moved to glossary. * Non-functional Requirements: Adherence to Clean Code Principles: Changed priority from \"0\" to \"+\" and updated the description accordingly. * Non-functional Requirements: Type of delivery: Fixed typo in description. Changed \"DOCX\" to \"HTML\". * Requirements: Functional Requirements: Changed Id from \"FA\" to \"FR\". * Requirements: Non-functional Requirements: Changed Id from \"QA\" to \"NFR\". * Component diagrams: Component diagrams: Updated notation and changed inconsistent interface labels. * Component diagrams: Component diagrams: Updated descriptions for all component diagrams. + Used plugins: Live Share: Added used plugin. * Use-case diagrams: Moderator-Client: Division into \"Start Application\", \"Play Game\" and \"End Application\" diagrams. - StoryFlow diagram: StoryFlow diagram: Removed obsolete StoryFlow diagram. * Non-functional Requirements: Usage of online voting solutions:\" Updated the description to clarify that the voting tool will be made by the team.","title":"Version 0.1.1 - First revision of the architecture design"},{"location":"changehistory/#version-010-architecture-design","text":"This is the initial version of the Technical Specifications and thus has no changelog. The next version, which will focus on the component/detailed design, will be the first version with a changelog.","title":"Version 0.1.0 - Architecture design"},{"location":"glossary/","text":"Glossary The glossary contains a list of specific terms and their meaning in the context of the project. Furthermore they may also contain examples or descriptions of what they are or can be. Actors and roles This section includes all actors and roles involved in the system. Actors can be people, but also specifically created software and hardware or third party technical systems. Moderator DESCRIPTION Observes and comments on the game. In case of a ServerLogic outage, the moderator is also responsible for taking over the game and finishing it offline. IS-A Human CAN-BE - EXAMPLE - PlayerAudience DESCRIPTION Viewers playing the game through StoryFlowDecisions. IS-A Human CAN-BE - EXAMPLE - Participants DESCRIPTION A person that participates and interacts with the game in any way. IS-A Human CAN-BE Moderator, PlayerAudience EXAMPLE - Customer DESCRIPTION The customer requires that the product meets certain requirements and is the first point of contact for questions and feedback. IS-A Human CAN-BE - EXAMPLE - Moderator-Client DESCRIPTION The Moderator-Client offers a graphical interface through which Moderator and PlayerAudience can interact with the game. The Moderator-Client can establish a connection to the ServerLogic, to include the PlayerAudience in the game, or play the game locally without connecting to a ServerLogic. In case of a ServerLogic connection the Moderator-Client visualizes and logically implements the output of the ServerLogic. IS-A Component CAN-BE - EXAMPLE - PlayerAudience-Client DESCRIPTION The PlayerAudience-Client provides a graphical interface through which PlayerAudience can interact with the ServerLogic to participate in polls. The PlayerAudience-Client establishes a direct connection to the ServerLogic via a web interface. IS-A Component CAN-BE - EXAMPLE - Client DESCRIPTION A client serves as a graphical interface through which a participant can interact with the ServerLogic and the game. IS-A Component CAN-BE Moderator-Client, PlayerAudience-Client EXAMPLE - ServerLogic DESCRIPTION The ServerLogic serves as an interface for the communication between the Moderator-Client and the PlayerAudience-Clients. The ServerLogic contains a logical unit responsible for setting up votes and evaluating them. IS-A Component CAN-BE - EXAMPLE - Server DESCRIPTION The server is a piece of physical computer hardware that hosts the ServerLogic and the PlayerAudience-Client. IS-A - CAN-BE - EXAMPLE - Expertise This section contains a collection of information regarding technical terms that are used in the context of the project. StoryFlowDecision DESCRIPTION A special event within the game where the PlayerAudience needs to take a decision through online voting which influences the further StoryFlow. After a StoryFlowDecision the PlayerCharacterStatusValues may increase or decrease by several levels. If the ServerLogic is not available, the moderator decides the StoryFlowDecision. IS-A - CAN-BE - EXAMPLE - StoryFlow DESCRIPTION The actual flow of the game-story. The Story contains elements where the PlayerAudience needs to make a StoryFlowDecision and depending on the decision, the StoryFlow progresses in different StoryBranches. IS-A - CAN-BE - EXAMPLE - StoryBranch DESCRIPTION A branch of the non-linear StoryFlow of the game. IS-A - CAN-BE - EXAMPLE - PlayerCharacterStatusValue DESCRIPTION The PlayerCharacter has different character status values which improve or change during the course of the game. The PlayerCharacterStatusValues are displayed via a PlayerCharacterStatusBox. IS-A - CAN-BE Programming, Analytics, Communication, Partying EXAMPLE - Role-playing game DESCRIPTION QualityQuest is a role-playing game. A role-playing game is a game in which players assume the roles of characters in a fictional setting. IS-A - CAN-BE QualityQuest EXAMPLE - PlayerCharacterStatusBox DESCRIPTION An info box that displays the different PlayerCharacterStatusValues and the portrait of the PlayerCharacter. The box can be displayed for example in the lower left corner. IS-A - CAN-BE - EXAMPLE - PlayerCharacter DESCRIPTION The virtual representation of the PlayerAudience in the game. At the beginning of the game the PlayerAudience chooses a PlayerCharacter from a collection of predefined PlayerCharacters with different PlayerCharacterStatusValues. The PlayerCharacter has different PlayerCharacterStatusValues and a portrait. IS-A - CAN-BE - EXAMPLE - Randomness DESCRIPTION The progression in the StoryFlow after a StoryFlowDecision is decided by on of the following randomness options: ZeroRandomness DiceRandomness IS-A - CAN-BE ZeroRandomness, DiceRandomness EXAMPLE - ZeroRandomness DESCRIPTION The StoryFlowDecision leads directly to the next StoryBranch. The random element is zero. IS-A Randomness CAN-BE - EXAMPLE - DiceRandomness DESCRIPTION After a StoryFlowDecision a six-sided dice is rolled, which initiates the further StoryFlow and selects the next StoryBranch. IS-A Randomness CAN-BE - EXAMPLE - Programming DESCRIPTION A status value of the PlayerCharacter. Influences how well the character can program, for example less time is needed to program tests. IS-A CharacterStatusValue CAN-BE - EXAMPLE PlayerCharacter James has the programming-skill at 8. Analytics DESCRIPTION Determines how well the character can analyze situations and tasks, which increases the chance of success. IS-A CharacterStatusValue CAN-BE - EXAMPLE 4 of 6 DiceRandomness possibilities lead to a positive event, because of high analytic stats. Communication DESCRIPTION Communication is a StatusValue of the PlayerCharacter. Communication influences how eloquent the PlayerCharacter is, e.g how well he works in a team or how well he deals with customers. IS-A CharacterStatusValue CAN-BE - EXAMPLE - Partying DESCRIPTION A character with a good partying skill can make more contacts at a party more quickly. IS-A CharacterStatusValue CAN-BE - EXAMPLE - Online voting DESCRIPTION The PlayerAudience selects its decisions for a StoryFlowDecision via the PlayerAudience-Client through the ServerLogic. The connection with the ServerLogic is established over the PlayerAudience-Client by entering a QR-Code or URL. IS-A - CAN-BE - EXAMPLE - Sidekick-Pet DESCRIPTION Can be unlocked by the PlayerAudience through a StoryFlowDecision. Helps the player in StoryFlowDecisions with helpful tips and suggestions. IS-A - CAN-BE - EXAMPLE - Play-Time DESCRIPTION The time it takes to finish a game. The time needed for QualityQuest should be about 15 to 20 minutes. IS-A - CAN-BE - EXAMPLE - Voting-Timer DESCRIPTION Timer that is triggered by a StoryFlowDecision. While the timer is running the PlayerAudience has to vote. The moderator can stop the timer with the pause button. IS-A - CAN-BE - EXAMPLE The PlayerAudience has 30 seconds to vote on a StoryFlowDecision. PauseButton DESCRIPTION Button with which the game, and the Voting-Timer, can be paused. IS-A - CAN-BE - EXAMPLE - Network protocol DESCRIPTION The network protocol shall define clearly and well-defined how clients and ServerLogic shall communicate with each other in order to accept messages. If a client increasingly does not adhere to the communication protocol, a communication protocol violation is detected. IS-A - CAN-BE - EXAMPLE - Online-Session DESCRIPTION The process of playing the game in Online-Mode, including a PlayerAudience. The moderator is always responsible for creating the Online-Session and the PlayerAudience joins the Online-Session via the ServerLogic. IS-A - CAN-BE - EXAMPLE - Offline-Session DESCRIPTION The process of playing the game in Offline-Mode, without a PlayerAudience. The moderator creates a local Offline-Session on their device and plays the game on their own. IS-A - CAN-BE - EXAMPLE - Globally Unique Identifier (GUID) DESCRIPTION A globally unique identifier (GUID) is a 128-bit number used to identify information in computer systems. IS-A - CAN-BE - EXAMPLE A random GUID could have the following form: 0f8fad5b-d9cb-469f-a165-70867728950e Offline-Mode DESCRIPTION The Moderator-Client is not connected to a ServerLogic and thus also not connected to any PlayerAudience-Clients. IS-A - CAN-BE - EXAMPLE - Online-Mode DESCRIPTION The Moderator-Client is connected to a ServerLogic which enables the option for PlayerAudience-Clients to join the Online-Session. IS-A - CAN-BE - EXAMPLE - StoryGraph DESCRIPTION A graph-based representation of the StoryFlow and the different StoryFlowDecisions that can occur during the course of the game and can lead to the different StoryBranches. IS-A - CAN-BE - EXAMPLE -","title":"Glossary"},{"location":"glossary/#glossary","text":"The glossary contains a list of specific terms and their meaning in the context of the project. Furthermore they may also contain examples or descriptions of what they are or can be.","title":"Glossary"},{"location":"glossary/#actors-and-roles","text":"This section includes all actors and roles involved in the system. Actors can be people, but also specifically created software and hardware or third party technical systems.","title":"Actors and roles"},{"location":"glossary/#expertise","text":"This section contains a collection of information regarding technical terms that are used in the context of the project.","title":"Expertise"},{"location":"network-protocol/","text":"Network protocol General information The \"WebSocket\" class provided by C# is used for communication between the Moderator-Client and the ServerLogic. When starting an Online-Session, the moderator is asked for a URL and password. The URL leads to the game ServerLogic and is then used to establish a WebSocket connection with the ServerLogic. Once the connection is established, the Moderator-Client sends a RequestOpenSessionMessage to the ServerLogic, which contains the Moderator-Client's GUID and the entered password. If this password is incorrect or if the Moderator-Client takes too long to send the RequestOpenSessionMessage , the WebSocket connection is automatically terminated. If not, a Online-Session is opened, and the PlayerAudience can join. The messages sent back and forth between Moderator-Client and ServerLogic are all in JSON format. The security and persistence of communication is guaranteed by the use of WebSockets in combination with the HTTPS protocol. In addition, for communication integral data is stored on the ServerLogic in hashed form. This includes the ServerLogic password and the moderator's GUID. ServerLogic logs The ServerLogic log stores the Moderator-Client's GUID, the PlayerAudience-Client GUIDs, the voting results, and the sessionKey. If the ServerLogic should at any time lose the connection to the internet or have to close the current Online-Session, this will provide the following advantages: The logged Moderator-Client's GUID can still be used to send a ReconnectMessage to the ServerLogic without requiring the password to be re-entered. This allows the Online-Session to resume easily without having to change sessionKey or re-entering the password. The logged PlayerAudience-Client GUIDs can be used for keeping track of the PlayerAudience-Clients connected to the ServerLogic. The logged sessionKey allows the PlayerAudience-Clients to quickly and easily reconnect to the Online-Session without having to enter a new sessionKey. The logged voting results realize postgame statistics. Differences between starting in Online-Mode and Offline-Mode When starting the application, the game offers the possibility to start the game either in Online-Mode with a server, or in Offline-Mode. Attention must be paid to a few important points here: If you start the game as an Online-Session, you can switch between Online-Mode and Offline-Mode at any given time. If you start the game in Offline-Mode, the game remains in Offline-Mode until the moderator starts an Online-Session via the main menu. This decision was made because one wants to avoid that the moderator has to enter the URL to the ServerLogic and the password during the game. For network protocol purposes, a flag is set to distinguish whether the game was initialized in Online-Mode or Offline-Mode, so that sending and receiving messages is disregarded right from the start of the game. Behaviour in the event of connection loss A clear distinction must be made between three different cases. First of all, we refer here to the view of a single, specific PlayerAudience-Client, which can lose the connection to the ServerLogic, but this behaviour is not exclusive to single PlayerAudience-Client and can also happen to multiple PlayerAudience-Clients, but due to the same reasons listed below. Secondly, the ServerLogic can also lose the connection to all clients - in other words, a complete loss of connection to the ServerLogic. Finally, it is possible for only the Moderator-Client to lose its connection to the ServerLogic, while all other clients can maintain their connection to the ServerLogic. Since this can have very different effects, the following section specifies how, these cases may occur and which actors have to do what in order to deal correctly with the loss of connection. Moderator-Client connection loss A selection of possible causes for the loss of connection from the Moderator-Client to the ServerLogic are the following: The moderator closes the client, and thus the connection to the ServerLogic. The moderator's end device loses the connection to the network, and thus to the ServerLogic. The ServerLogic does not react within 5 seconds after receiving the Moderator-Client's message. If the Moderator-Client should at any time lose the connection to the ServerLogic, it automatically switches to Offline-Mode and notifies the moderator. The moderator can then continue to play the game in form of an Offline-Session. In the meantime, the Moderator-Client continuously sends RequestServerStatusMessages to the ServerLogic to determine if the ServerLogic is back online. When the Moderator-Client receives a ServerStatusMessage , it informs the moderator that the Online-Session can be resumed. In this case, the moderator can either go back into Online-Mode via an UI element or continue playing in Offline-Mode. This can result in the following three scenarios: The ServerLogic is reachable again and the connection can be re-established. Furthermore, the Online-Session on the ServerLogic was not closed and the PlayerAudience-Clients are still connected to the ServerLogic. In that case the Moderator-Client only has to send a ReconnectMessage to return to normal gameplay, since the Online-Session is still going. The ServerLogic is reachable again and the connection can be re-established, but the Online-Session on the ServerLogic has been closed and the PlayerAudience-Clients are no longer connected to the ServerLogic. In that case the Moderator-Client only has to send a ReconnectMessage , since the logs of the ServerLogic still hold the GUID of the Moderator-Client. This way the Online-Session can be restored without entering the password again and the PlayerAudience-Clients can simply reconnect to the ServerLogic, through the same QR-code, URL and sessionKey, to be able to participate in the game again. The Moderator-Client still cannot reach the ServerLogic and the game continues in Offline-Mode. If the moderator ever returns to the main menu, the Online-Session must be started anew by connecting to the ServerLogic via password again. PlayerAudience-Client connection loss A selection of possible causes for the loss of connection from the PlayerAudience-Client to the ServerLogic are the following: The audience member closes the website, and thus the connection to the ServerLogic. The audience member's end device loses the connection to the network, and thus to the ServerLogic. The ServerLogic goes offline or loses its connection to the Internet. Since no data of the audience member has to be saved and it has absolutely no relevance for the course of the game whether the spectator has been part of the Online-Session before or not, he can connect to the ServerLogic again at any time and does not have to suffer any disadvantages compared to the other PlayerAudience-Clients. Even audience members who were not connected to the ServerLogic at all before the start of the Online-Session can join in this way without any problems. ServerLogic connection loss A selection of possible causes for the loss of connection from the ServerLogic to all clients are the following: The network carrying the ServerLogic breaks down. The physical server on which the ServerLogic resides is not reachable (either because of internet problems or because the server crashed). The logic of the game ServerLogic has crashed. Although all these issues boil down to the same result - the inaccessibility of the ServerLogic - in the first case, one can hope that the network the ServerLogic is located on will recover in the course of the game. Though, in the second and third case, nothing can be done for the time being and the game must be played offline by the moderator. However, it should then be checked whether and how the logic of the game ServerLogic was related to the problem and how this problem can be avoided or fixed in the future. What happens if a Moderator-Client wants to connect to the ServerLogic when a Moderator-Client is already connected to the ServerLogic? If the new Moderator-Client has entered the required password correctly, the old Moderator-Client is disconnected from the ServerLogic and a new Online-Session is started. This has the following reasons: Since the password is only known to the ServerLogic owners, the moderator cannot be thrown out by a random person. The moderator can start a new Online-Session at any time and does not have to worry about if there is still an Online-Session going on somewhere. In the event that the ServerLogic mistakenly thinks that an Online-Session is already in progress, the ServerLogic will not be blocked and can continue to be used without problems. What happens in case of an illegal message being recieved? Moderator-Client and ServerLogic should never send illegal messages , as this is a sign of a damaged architecture or insufficient network protocol. Should this marginal case occur nevertheless, the connection between Moderator-Client and ServerLogic should be cut and the illegal message ignored. The game is then continued in Offline-Mode, unless the moderator chooses to go back into Online-Mode and reconnect to the ServerLogic. What happens in case of a pause? Breaks are always initiated by the Moderator-Client and cannot be initiated by the ServerLogic under any circumstances. If the Moderator-Client initiates a pause, the following events will occur: The game on the Moderator-Client is paused completely and a pause screen appears. Despite the pause, the ServerLogic continues to communicate with the Moderator-Client and the PlayerAudience-Clients. If a vote is in progress, the ServerLogic will pause the voting timer. What about the communication between PlayerAudience-Clients and ServerLogic? Communication between the ServerLogic and the PlayerAudience-Clients is not specified as part of the network protocol because the back-end of the PlayerAudience-Clients and the general ServerLogic logic are on the same physical server and can thus communicate directly with each other. This communication happens locally, through different functions, and does not need pre-defined message types, like the communication between Moderator-Client and ServerLogic. Since the front-end of the PlayerAudience-Clients is a web page, nothing more specific needs to be defined here either, as pre-implemented solutions of HTML and JavaScript can be used to implement the communication between PlayerAudience-Clients and ServerLogic. Apart from that, the Observer-pattern is used to make the communication simple and efficient. Here the PlayerAudience-Clients subscribe to the ServerLogic to observe it. MessageContainer Defines the container format for a message. All following fields can be found in every network message, whereas a debugMessage is purely optional. class MessageContainer { Guid ModeratorId ; MessageType Type ; DateTime CreationDate ; string DebugMessage ; } moderatorId: The individual identifier assigned to the Moderator-Client. Only the Moderator-Client sends this id to the ServerLogic to identify itself. The ServerLogic leaves this field empty. type: Specifies the type of the message to be able to parse it accordingly. creationDate: The timestamp of the message. debugMessage: Can be used during development to transport additional data between ServerLogic and Moderator-Client. This way, in case of a non parsable message, or an error occurring, information can be carried to the Moderator-Client directly for quick access, without the need to search through the logs. MessageType Enum Lists all message types. The structuring by comments is only for overview and has no semantic meaning whatsoever. All messages are identified by the MessageContainer . enum MessageType { // Initialization RequestOpenSession , SessionOpened , AudienceStatus , RequestServerStatus , ServerStatus , Reconnect , ReconnectSuccessful , RequestGameStart , GameStarted , // Voting RequestStartVoting , VotingStarted , VotingEnded , // Control messages Error , RequestGamePausedStatusChange , GamePausedStatus , // Postgame RequestCloseSession , SessionClosed } Who can send which MessageType? Listing which participant may send which message, the order of the listing is based on the MessageType . Who can send which MessageType? Messages Moderator-Client ServerLogic Initialization RequestOpenSession \u2713 SessionOpened \u2713 AudienceStatus \u2713 RequestServerStatus \u2713 ServerStatus \u2713 Reconnect \u2713 ReconnectSuccessful \u2713 RequestGameStart \u2713 GameStarted \u2713 Voting RequestStartVoting \u2713 VotingStarted \u2713 VotingEnded \u2713 Control messages Error \u2713 RequestGamePausedStatusChange \u2713 GamePausedStatus \u2713 Postgame RequestCloseSession \u2713 SessionClosed \u2713 ErrorType Enum All possible causes for an ErrorMessage , which can occur in the context of communication between ServerLogic and Moderator-Client. These apply both when establishing the connection and during the general course of the game. enum ErrorType { WrongPassword , UnknownGuid , IllegalPauseAction , SessionDoesNotExist , NewModerator , IllegalMessage } WrongPassword: Is triggered when a RequestOpenSessionMessage contains the wrong password. UnknownGuid: Is triggered when a message with an unknown moderatorId is sent to the ServerLogic. IllegalPauseAction: Is triggered if one of the following cases applies: A request to pause the game reaches the ServerLogic even though the game is already paused. A request to continue the game reaches the ServerLogic even though the game has not been paused previously. SessionDoesNotExist: Is triggered when an attempt is made to interact with an Online-Session that does not exist. NewModerator: Is triggered and sent to the current Moderator-Client, when a new Moderator connects to the ServerLogic via RequestOpenSessionMessage . IllegalMessage: Is triggered when an unknown message type is received, or when a message arrives at the ServerLogic out of order. More precise details are to be specified in the errorMessage. Detailed message definitions Initialisation RequestOpenSessionMessage Specification of a MessageContainer with the type MessageType ::RequestOpenSession . This message is sent from the Moderator-Client to the ServerLogic when the moderator wants to connect to the ServerLogic. The password confirms that the moderator is allowed to use the ServerLogic and the GUID of the moderator will be saved in the logs henceforth, for further communication. In addition, the creation of an Online-Session is also requested from the ServerLogic at the same time. class RequestOpenSessionMessage : MessageContainer { string Password ; } Password: The password, required by the ServerLogic, to establish a connection with the ServerLogic. The ServerLogic responds with a SessionOpenedMessage . SessionOpenedMessage Specification of a MessageContainer with the type MessageType ::SessionOpened . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestOpenSessionMessage to provide the Moderator-Client with all necessary data to allow the audience to join the Online-Session. class SessionOpenedMessage : MessageContainer { string SessionKey ; Uri DirectURL ; Bitmap QrCode ; } SessionKey: A randomly generated Online-Session key, of size 6, required by the audience to join the Online-Session, after connecting to the ServerLogic. DirectURL: A direct URL that the audience can use to connect to the ServerLogic via the PlayerAudience-Client should the QR code not be usable. QrCode: A QR-code automatically generated by the ServerLogic which can be scanned by the audience to connect to the ServerLogic. AudienceStatusMessage Specification of a MessageContainer with the type MessageType ::AudienceStatus . This message is sent from the ServerLogic to Moderator-Client every 3 seconds to inform the Moderator-Client about the amount of PlayerAudience members that already connected to the server. This message is only sent in the time-frame after the SessionOpenedMessage , and before the GameStartedMessage , was received by the Moderator-Client. class AudienceStatusMessage : MessageContainer { int AudienceCount ; } AudienceCount: The amount of PlayerAudience members that connected to the current session. RequestServerStatusMessage Specification of a MessageContainer with the type MessageType ::RequestServerStatus . This message is sent from the Moderator-Client to the ServerLogic if there is currently no connection to a ServerLogic. This message is sent to the ServerLogic at regular intervals until the ServerLogic returns a response in form of a ServerStatusMessage . If a ServerStatusMessage is received by the Moderator-Client at any given time, the moderator is notified that a connection to the ServerLogic is possible, and at the same time, RequestServerStatus messages are stopped being sent to the ServerLogic. class RequestServerStatusMessage : MessageContainer { // No extra fields needed } The ServerLogic responds with a ServerStatusMessage . ServerStatusMessage Specification of a MessageContainer with the type MessageType ::ServerStatus . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestServerStatusMessage to confirm that the ServerLogic is available for a connection. class ServerStatusMessage : MessageContainer { // No extra fields needed } ReconnectMessage Specification of a MessageContainer with the type MessageType ::Reconnect . This message is sent from the Moderator-Client to the ServerLogic to reestablish a lost connection. For this purpose, the Moderator-Client's GUID is required for comparison with the previously saved Moderator-Client GUID. This message shall only be sent when the Moderator-Client is still in-game, otherwise a new Online-Session has to be opened through a RequestOpenSessionMessage . class ReconnectMessage : MessageContainer { // No extra fields needed } The ServerLogic responds with a ReconnectSuccessfulMessage . ReconnectSuccessfulMessage Specification of a MessageContainer with the type MessageType ::ReconnectSuccessful . This message is sent from the the ServerLogic to the Moderator-Client to confirm that a lost connection has been reestablished. class ReconnectSuccessfulMessage : MessageContainer { // No extra fields needed } RequestGameStartMessage Specification of a MessageContainer with the type MessageType ::RequestGameStart . This message is sent from the Moderator-Client to the ServerLogic to request the start of the game with the current Online-Session. class RequestGameStartMessage : MessageContainer { // No extra fields needed } The ServerLogic responds with a GameStartedMessage . GameStartedMessage Specification of a MessageContainer with the type MessageType ::GameStarted . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestGameStartMessage to inform the Moderator-Client that the game has started. This results in the Moderator-Client starting the game locally and the ServerLogic awaiting further communication. class GameStartedMessage : MessageContainer { // No extra fields needed } Voting RequestStartVotingMessage Specification of a MessageContainer with the type MessageType ::RequestStartVoting . This message is sent from the Moderator-Client to the ServerLogic to request the start of a voting phase. For this purpose the Moderator-Client provides the ServerLogic with different options for the audience to choose from. It also provides the ServerLogic with a time-limit on how long the PlayerAudience-Clients may vote on the topic. class RequestStartVotingMessage : MessageContainer { int VotingTime ; Dictionary < Guid , string > VotingOptions ; } VotingTime: The time in seconds that PlayerAudience-Clients have to cast their vote. VotingOptions: Contains the GUIDs of the respective voting option as the key and textual description of the voting option as the value. The ServerLogic responds with a VotingStartedMessage and some time after with a VotingEndedMessage . VotingStartedMessage Specification of a MessageContainer with the type MessageType ::VotingStarted . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestStartVotingMessage to confirm the start of a voting phase with the provided voting options. class VotingStartedMessage : MessageContainer { // No extra fields needed } VotingEndedMessage Specification of a MessageContainer with the type MessageType ::VotingEnded . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestStartVotingMessage , after the voting time has expired. The winning option and the statistical results of the vote are sent back to the Moderator-Client. class VotingEndedMessage : MessageContainer { Guid WinningOption ; Dictionary < Guid , int > VotingResults ; } WinningOption: The GUID of the option that got the most votes from the PlayerAudience. VotingResults: Contains the GUIDs of the option as the key and the respective amount of received votes as the value. Control messages ErrorMessage Specification of a MessageContainer with the type MessageType ::Error . This message is sent from the ServerLogic to the Moderator-Client in case of a disconnection initiated by the ServerLogic and explains the reason for the disconnection. class ErrorMessage : MessageContainer { ErrorType ErrorMessageType ; string ErrorMessageText ; } ErrorMessageType: Specifies the reason for the occurred error. ErrorMessageText: Optional, more detailed description of the occurred error. RequestGamePausedStatusChangeMessage Specification of a MessageContainer with the type MessageType ::RequestGamePausedStatusChange . This message is sent from the Moderator-Client to the ServerLogic to switch the game between running and being paused. class RequestGamePausedStatusChangeMessage : MessageContainer { bool GamePaused ; } GamePaused: Specifies whether the game is to be paused or whether the already paused game is to be continued. With true indicating that the game is to be paused, and false indicating that the game is to be continued. The ServerLogic responds with a GamePauseStatusMessage . GamePauseStatusMessage Specification of a MessageContainer with the type MessageType ::GamePausedStatus . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestGamePausedStatusChangeMessage , to confirm that the game is now either continuing or being paused. class GamePauseStatusMessage : MessageContainer { bool GamePaused ; } GamePaused: Specifies whether the game is being paused or whether the already paused game is being continued. With true indicating that the game has been paused, and false indicating that the game is continuing. Postgame RequestCloseSessionMessage Specification of a MessageContainer with the type MessageType ::RequestCloseSession . This message is sent from the Moderator-Client to the ServerLogic to tell the ServerLogic to close the Online-Session and with that the connection to the PlayerAudience-Clients. It also commands the ServerLogic to clear the logs. class RequestCloseSessionMessage : MessageContainer { string SessionKey ; } SessionKey: The key of the to be closed Online-Session. The ServerLogic responds with a SessionClosedMessage . SessionClosedMessage Specification of a MessageContainer with the type MessageType ::SessionClosed . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestCloseSessionMessage , to confirm that the Online-Session has been successfully closed and that the logs have been cleared completely. In addition to that, the statistics of the Online-Session are returned to the Moderator-Client, which can be used to display every conducted vote and which option got how many votes. class SessionClosedMessage : MessageContainer { Dictionary < string , int > Statistics ; } Statistics: Contains the id of the option as the key and the respective amount of received votes as the value. Sequence diagrams of typical communicational processes The following diagrams always show typical communication processes between clients and ServerLogic. Only the core contents of the communication, which are relevant for the understanding, are pointed out. For the sake of clarity, the specific message verification mechanisms of the clients and the ServerLogic are not shown, as they are active at all times and check each message for correctness. For example, it is not specifically stated that an IllegalMessage error can be thrown with every message sent or received. Also, detailed procedures that handle multiple processes and deal with errors are not listed here, as these are explicit processes, such as a ReconnectMessage . Start Online-Session This diagram illustrates a typical process from the creation of an online session to the start of the game. It also describes typical errors that can occur when opening the session and optional operations that can be performed by the server and the clients. List of MessageTypes used: RequestOpenSessionMessage , SessionOpenedMessage , AudienceStatusMessage , RequestGameStartMessage , GameStartedMessage , ErrorMessage Player reconnect This diagram illustrates a typical process how a Moderator-Client checks if the connection to a ServerLogic has been restored and optionally how the Moderator-Client reconnects to a running session. List of MessageTypes used: RequestServerStatusMessage , ServerStatusMessage , ReconnectMessage , ReconnectSuccessfulMessage Pause game This diagram illustrates a typical process of how a Moderator-Client initializes a global pause via the ServerLogic. It also describes what happens in the case of an ongoing vote and what typical errors can occur. List of MessageTypes used: RequestGamePausedStatusChangeMessage , GamePauseStatusMessage , ErrorMessage Voting phase This diagram illustrates a typical process of how a Moderator-Client initialises an election phase via the ServerLogic and how the PlayerAudience-Clients are involved. List of MessageTypes used: RequestStartVotingMessage , VotingStartedMessage , VotingEndedMessage New moderator This diagram illustrates a typical process how a Moderator-Client replaces another Moderator-Client while opening a new Online-Session. List of MessageTypes used: RequestOpenSessionMessage , ErrorMessage , SessionOpenedMessage End Online-Session This diagram illustrates a typical process of how a Moderator-Client ends an existing Online-Session and how the PlayerAudience-Clients are affected. List of MessageTypes used: RequestCloseSessionMessage , SessionClosedMessage","title":"Network protocol"},{"location":"network-protocol/#network-protocol","text":"","title":"Network protocol"},{"location":"network-protocol/#general-information","text":"The \"WebSocket\" class provided by C# is used for communication between the Moderator-Client and the ServerLogic. When starting an Online-Session, the moderator is asked for a URL and password. The URL leads to the game ServerLogic and is then used to establish a WebSocket connection with the ServerLogic. Once the connection is established, the Moderator-Client sends a RequestOpenSessionMessage to the ServerLogic, which contains the Moderator-Client's GUID and the entered password. If this password is incorrect or if the Moderator-Client takes too long to send the RequestOpenSessionMessage , the WebSocket connection is automatically terminated. If not, a Online-Session is opened, and the PlayerAudience can join. The messages sent back and forth between Moderator-Client and ServerLogic are all in JSON format. The security and persistence of communication is guaranteed by the use of WebSockets in combination with the HTTPS protocol. In addition, for communication integral data is stored on the ServerLogic in hashed form. This includes the ServerLogic password and the moderator's GUID.","title":"General information"},{"location":"network-protocol/#serverlogic-logs","text":"The ServerLogic log stores the Moderator-Client's GUID, the PlayerAudience-Client GUIDs, the voting results, and the sessionKey. If the ServerLogic should at any time lose the connection to the internet or have to close the current Online-Session, this will provide the following advantages: The logged Moderator-Client's GUID can still be used to send a ReconnectMessage to the ServerLogic without requiring the password to be re-entered. This allows the Online-Session to resume easily without having to change sessionKey or re-entering the password. The logged PlayerAudience-Client GUIDs can be used for keeping track of the PlayerAudience-Clients connected to the ServerLogic. The logged sessionKey allows the PlayerAudience-Clients to quickly and easily reconnect to the Online-Session without having to enter a new sessionKey. The logged voting results realize postgame statistics.","title":"ServerLogic logs"},{"location":"network-protocol/#differences-between-starting-in-online-mode-and-offline-mode","text":"When starting the application, the game offers the possibility to start the game either in Online-Mode with a server, or in Offline-Mode. Attention must be paid to a few important points here: If you start the game as an Online-Session, you can switch between Online-Mode and Offline-Mode at any given time. If you start the game in Offline-Mode, the game remains in Offline-Mode until the moderator starts an Online-Session via the main menu. This decision was made because one wants to avoid that the moderator has to enter the URL to the ServerLogic and the password during the game. For network protocol purposes, a flag is set to distinguish whether the game was initialized in Online-Mode or Offline-Mode, so that sending and receiving messages is disregarded right from the start of the game.","title":"Differences between starting in Online-Mode and Offline-Mode"},{"location":"network-protocol/#behaviour-in-the-event-of-connection-loss","text":"A clear distinction must be made between three different cases. First of all, we refer here to the view of a single, specific PlayerAudience-Client, which can lose the connection to the ServerLogic, but this behaviour is not exclusive to single PlayerAudience-Client and can also happen to multiple PlayerAudience-Clients, but due to the same reasons listed below. Secondly, the ServerLogic can also lose the connection to all clients - in other words, a complete loss of connection to the ServerLogic. Finally, it is possible for only the Moderator-Client to lose its connection to the ServerLogic, while all other clients can maintain their connection to the ServerLogic. Since this can have very different effects, the following section specifies how, these cases may occur and which actors have to do what in order to deal correctly with the loss of connection.","title":"Behaviour in the event of connection loss"},{"location":"network-protocol/#moderator-client-connection-loss","text":"A selection of possible causes for the loss of connection from the Moderator-Client to the ServerLogic are the following: The moderator closes the client, and thus the connection to the ServerLogic. The moderator's end device loses the connection to the network, and thus to the ServerLogic. The ServerLogic does not react within 5 seconds after receiving the Moderator-Client's message. If the Moderator-Client should at any time lose the connection to the ServerLogic, it automatically switches to Offline-Mode and notifies the moderator. The moderator can then continue to play the game in form of an Offline-Session. In the meantime, the Moderator-Client continuously sends RequestServerStatusMessages to the ServerLogic to determine if the ServerLogic is back online. When the Moderator-Client receives a ServerStatusMessage , it informs the moderator that the Online-Session can be resumed. In this case, the moderator can either go back into Online-Mode via an UI element or continue playing in Offline-Mode. This can result in the following three scenarios: The ServerLogic is reachable again and the connection can be re-established. Furthermore, the Online-Session on the ServerLogic was not closed and the PlayerAudience-Clients are still connected to the ServerLogic. In that case the Moderator-Client only has to send a ReconnectMessage to return to normal gameplay, since the Online-Session is still going. The ServerLogic is reachable again and the connection can be re-established, but the Online-Session on the ServerLogic has been closed and the PlayerAudience-Clients are no longer connected to the ServerLogic. In that case the Moderator-Client only has to send a ReconnectMessage , since the logs of the ServerLogic still hold the GUID of the Moderator-Client. This way the Online-Session can be restored without entering the password again and the PlayerAudience-Clients can simply reconnect to the ServerLogic, through the same QR-code, URL and sessionKey, to be able to participate in the game again. The Moderator-Client still cannot reach the ServerLogic and the game continues in Offline-Mode. If the moderator ever returns to the main menu, the Online-Session must be started anew by connecting to the ServerLogic via password again.","title":"Moderator-Client connection loss"},{"location":"network-protocol/#playeraudience-client-connection-loss","text":"A selection of possible causes for the loss of connection from the PlayerAudience-Client to the ServerLogic are the following: The audience member closes the website, and thus the connection to the ServerLogic. The audience member's end device loses the connection to the network, and thus to the ServerLogic. The ServerLogic goes offline or loses its connection to the Internet. Since no data of the audience member has to be saved and it has absolutely no relevance for the course of the game whether the spectator has been part of the Online-Session before or not, he can connect to the ServerLogic again at any time and does not have to suffer any disadvantages compared to the other PlayerAudience-Clients. Even audience members who were not connected to the ServerLogic at all before the start of the Online-Session can join in this way without any problems.","title":"PlayerAudience-Client connection loss"},{"location":"network-protocol/#serverlogic-connection-loss","text":"A selection of possible causes for the loss of connection from the ServerLogic to all clients are the following: The network carrying the ServerLogic breaks down. The physical server on which the ServerLogic resides is not reachable (either because of internet problems or because the server crashed). The logic of the game ServerLogic has crashed. Although all these issues boil down to the same result - the inaccessibility of the ServerLogic - in the first case, one can hope that the network the ServerLogic is located on will recover in the course of the game. Though, in the second and third case, nothing can be done for the time being and the game must be played offline by the moderator. However, it should then be checked whether and how the logic of the game ServerLogic was related to the problem and how this problem can be avoided or fixed in the future.","title":"ServerLogic connection loss"},{"location":"network-protocol/#what-happens-if-a-moderator-client-wants-to-connect-to-the-serverlogic-when-a-moderator-client-is-already-connected-to-the-serverlogic","text":"If the new Moderator-Client has entered the required password correctly, the old Moderator-Client is disconnected from the ServerLogic and a new Online-Session is started. This has the following reasons: Since the password is only known to the ServerLogic owners, the moderator cannot be thrown out by a random person. The moderator can start a new Online-Session at any time and does not have to worry about if there is still an Online-Session going on somewhere. In the event that the ServerLogic mistakenly thinks that an Online-Session is already in progress, the ServerLogic will not be blocked and can continue to be used without problems.","title":"What happens if a Moderator-Client wants to connect to the ServerLogic when a Moderator-Client is already connected to the ServerLogic?"},{"location":"network-protocol/#what-happens-in-case-of-an-illegal-message-being-recieved","text":"Moderator-Client and ServerLogic should never send illegal messages , as this is a sign of a damaged architecture or insufficient network protocol. Should this marginal case occur nevertheless, the connection between Moderator-Client and ServerLogic should be cut and the illegal message ignored. The game is then continued in Offline-Mode, unless the moderator chooses to go back into Online-Mode and reconnect to the ServerLogic.","title":"What happens in case of an illegal message being recieved?"},{"location":"network-protocol/#what-happens-in-case-of-a-pause","text":"Breaks are always initiated by the Moderator-Client and cannot be initiated by the ServerLogic under any circumstances. If the Moderator-Client initiates a pause, the following events will occur: The game on the Moderator-Client is paused completely and a pause screen appears. Despite the pause, the ServerLogic continues to communicate with the Moderator-Client and the PlayerAudience-Clients. If a vote is in progress, the ServerLogic will pause the voting timer.","title":"What happens in case of a pause?"},{"location":"network-protocol/#what-about-the-communication-between-playeraudience-clients-and-serverlogic","text":"Communication between the ServerLogic and the PlayerAudience-Clients is not specified as part of the network protocol because the back-end of the PlayerAudience-Clients and the general ServerLogic logic are on the same physical server and can thus communicate directly with each other. This communication happens locally, through different functions, and does not need pre-defined message types, like the communication between Moderator-Client and ServerLogic. Since the front-end of the PlayerAudience-Clients is a web page, nothing more specific needs to be defined here either, as pre-implemented solutions of HTML and JavaScript can be used to implement the communication between PlayerAudience-Clients and ServerLogic. Apart from that, the Observer-pattern is used to make the communication simple and efficient. Here the PlayerAudience-Clients subscribe to the ServerLogic to observe it.","title":"What about the communication between PlayerAudience-Clients and ServerLogic?"},{"location":"network-protocol/#messagecontainer","text":"Defines the container format for a message. All following fields can be found in every network message, whereas a debugMessage is purely optional. class MessageContainer { Guid ModeratorId ; MessageType Type ; DateTime CreationDate ; string DebugMessage ; } moderatorId: The individual identifier assigned to the Moderator-Client. Only the Moderator-Client sends this id to the ServerLogic to identify itself. The ServerLogic leaves this field empty. type: Specifies the type of the message to be able to parse it accordingly. creationDate: The timestamp of the message. debugMessage: Can be used during development to transport additional data between ServerLogic and Moderator-Client. This way, in case of a non parsable message, or an error occurring, information can be carried to the Moderator-Client directly for quick access, without the need to search through the logs.","title":"MessageContainer"},{"location":"network-protocol/#messagetype-enum","text":"Lists all message types. The structuring by comments is only for overview and has no semantic meaning whatsoever. All messages are identified by the MessageContainer . enum MessageType { // Initialization RequestOpenSession , SessionOpened , AudienceStatus , RequestServerStatus , ServerStatus , Reconnect , ReconnectSuccessful , RequestGameStart , GameStarted , // Voting RequestStartVoting , VotingStarted , VotingEnded , // Control messages Error , RequestGamePausedStatusChange , GamePausedStatus , // Postgame RequestCloseSession , SessionClosed }","title":"MessageType Enum"},{"location":"network-protocol/#who-can-send-which-messagetype","text":"Listing which participant may send which message, the order of the listing is based on the MessageType . Who can send which MessageType? Messages Moderator-Client ServerLogic Initialization RequestOpenSession \u2713 SessionOpened \u2713 AudienceStatus \u2713 RequestServerStatus \u2713 ServerStatus \u2713 Reconnect \u2713 ReconnectSuccessful \u2713 RequestGameStart \u2713 GameStarted \u2713 Voting RequestStartVoting \u2713 VotingStarted \u2713 VotingEnded \u2713 Control messages Error \u2713 RequestGamePausedStatusChange \u2713 GamePausedStatus \u2713 Postgame RequestCloseSession \u2713 SessionClosed \u2713","title":"Who can send which MessageType?"},{"location":"network-protocol/#errortype-enum","text":"All possible causes for an ErrorMessage , which can occur in the context of communication between ServerLogic and Moderator-Client. These apply both when establishing the connection and during the general course of the game. enum ErrorType { WrongPassword , UnknownGuid , IllegalPauseAction , SessionDoesNotExist , NewModerator , IllegalMessage } WrongPassword: Is triggered when a RequestOpenSessionMessage contains the wrong password. UnknownGuid: Is triggered when a message with an unknown moderatorId is sent to the ServerLogic. IllegalPauseAction: Is triggered if one of the following cases applies: A request to pause the game reaches the ServerLogic even though the game is already paused. A request to continue the game reaches the ServerLogic even though the game has not been paused previously. SessionDoesNotExist: Is triggered when an attempt is made to interact with an Online-Session that does not exist. NewModerator: Is triggered and sent to the current Moderator-Client, when a new Moderator connects to the ServerLogic via RequestOpenSessionMessage . IllegalMessage: Is triggered when an unknown message type is received, or when a message arrives at the ServerLogic out of order. More precise details are to be specified in the errorMessage.","title":"ErrorType Enum"},{"location":"network-protocol/#detailed-message-definitions","text":"","title":"Detailed message definitions"},{"location":"network-protocol/#initialisation","text":"","title":"Initialisation"},{"location":"network-protocol/#requestopensessionmessage","text":"Specification of a MessageContainer with the type MessageType ::RequestOpenSession . This message is sent from the Moderator-Client to the ServerLogic when the moderator wants to connect to the ServerLogic. The password confirms that the moderator is allowed to use the ServerLogic and the GUID of the moderator will be saved in the logs henceforth, for further communication. In addition, the creation of an Online-Session is also requested from the ServerLogic at the same time. class RequestOpenSessionMessage : MessageContainer { string Password ; } Password: The password, required by the ServerLogic, to establish a connection with the ServerLogic. The ServerLogic responds with a SessionOpenedMessage .","title":"RequestOpenSessionMessage"},{"location":"network-protocol/#sessionopenedmessage","text":"Specification of a MessageContainer with the type MessageType ::SessionOpened . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestOpenSessionMessage to provide the Moderator-Client with all necessary data to allow the audience to join the Online-Session. class SessionOpenedMessage : MessageContainer { string SessionKey ; Uri DirectURL ; Bitmap QrCode ; } SessionKey: A randomly generated Online-Session key, of size 6, required by the audience to join the Online-Session, after connecting to the ServerLogic. DirectURL: A direct URL that the audience can use to connect to the ServerLogic via the PlayerAudience-Client should the QR code not be usable. QrCode: A QR-code automatically generated by the ServerLogic which can be scanned by the audience to connect to the ServerLogic.","title":"SessionOpenedMessage"},{"location":"network-protocol/#audiencestatusmessage","text":"Specification of a MessageContainer with the type MessageType ::AudienceStatus . This message is sent from the ServerLogic to Moderator-Client every 3 seconds to inform the Moderator-Client about the amount of PlayerAudience members that already connected to the server. This message is only sent in the time-frame after the SessionOpenedMessage , and before the GameStartedMessage , was received by the Moderator-Client. class AudienceStatusMessage : MessageContainer { int AudienceCount ; } AudienceCount: The amount of PlayerAudience members that connected to the current session.","title":"AudienceStatusMessage"},{"location":"network-protocol/#requestserverstatusmessage","text":"Specification of a MessageContainer with the type MessageType ::RequestServerStatus . This message is sent from the Moderator-Client to the ServerLogic if there is currently no connection to a ServerLogic. This message is sent to the ServerLogic at regular intervals until the ServerLogic returns a response in form of a ServerStatusMessage . If a ServerStatusMessage is received by the Moderator-Client at any given time, the moderator is notified that a connection to the ServerLogic is possible, and at the same time, RequestServerStatus messages are stopped being sent to the ServerLogic. class RequestServerStatusMessage : MessageContainer { // No extra fields needed } The ServerLogic responds with a ServerStatusMessage .","title":"RequestServerStatusMessage"},{"location":"network-protocol/#serverstatusmessage","text":"Specification of a MessageContainer with the type MessageType ::ServerStatus . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestServerStatusMessage to confirm that the ServerLogic is available for a connection. class ServerStatusMessage : MessageContainer { // No extra fields needed }","title":"ServerStatusMessage"},{"location":"network-protocol/#reconnectmessage","text":"Specification of a MessageContainer with the type MessageType ::Reconnect . This message is sent from the Moderator-Client to the ServerLogic to reestablish a lost connection. For this purpose, the Moderator-Client's GUID is required for comparison with the previously saved Moderator-Client GUID. This message shall only be sent when the Moderator-Client is still in-game, otherwise a new Online-Session has to be opened through a RequestOpenSessionMessage . class ReconnectMessage : MessageContainer { // No extra fields needed } The ServerLogic responds with a ReconnectSuccessfulMessage .","title":"ReconnectMessage"},{"location":"network-protocol/#reconnectsuccessfulmessage","text":"Specification of a MessageContainer with the type MessageType ::ReconnectSuccessful . This message is sent from the the ServerLogic to the Moderator-Client to confirm that a lost connection has been reestablished. class ReconnectSuccessfulMessage : MessageContainer { // No extra fields needed }","title":"ReconnectSuccessfulMessage"},{"location":"network-protocol/#requestgamestartmessage","text":"Specification of a MessageContainer with the type MessageType ::RequestGameStart . This message is sent from the Moderator-Client to the ServerLogic to request the start of the game with the current Online-Session. class RequestGameStartMessage : MessageContainer { // No extra fields needed } The ServerLogic responds with a GameStartedMessage .","title":"RequestGameStartMessage"},{"location":"network-protocol/#gamestartedmessage","text":"Specification of a MessageContainer with the type MessageType ::GameStarted . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestGameStartMessage to inform the Moderator-Client that the game has started. This results in the Moderator-Client starting the game locally and the ServerLogic awaiting further communication. class GameStartedMessage : MessageContainer { // No extra fields needed }","title":"GameStartedMessage"},{"location":"network-protocol/#voting","text":"","title":"Voting"},{"location":"network-protocol/#requeststartvotingmessage","text":"Specification of a MessageContainer with the type MessageType ::RequestStartVoting . This message is sent from the Moderator-Client to the ServerLogic to request the start of a voting phase. For this purpose the Moderator-Client provides the ServerLogic with different options for the audience to choose from. It also provides the ServerLogic with a time-limit on how long the PlayerAudience-Clients may vote on the topic. class RequestStartVotingMessage : MessageContainer { int VotingTime ; Dictionary < Guid , string > VotingOptions ; } VotingTime: The time in seconds that PlayerAudience-Clients have to cast their vote. VotingOptions: Contains the GUIDs of the respective voting option as the key and textual description of the voting option as the value. The ServerLogic responds with a VotingStartedMessage and some time after with a VotingEndedMessage .","title":"RequestStartVotingMessage"},{"location":"network-protocol/#votingstartedmessage","text":"Specification of a MessageContainer with the type MessageType ::VotingStarted . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestStartVotingMessage to confirm the start of a voting phase with the provided voting options. class VotingStartedMessage : MessageContainer { // No extra fields needed }","title":"VotingStartedMessage"},{"location":"network-protocol/#votingendedmessage","text":"Specification of a MessageContainer with the type MessageType ::VotingEnded . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestStartVotingMessage , after the voting time has expired. The winning option and the statistical results of the vote are sent back to the Moderator-Client. class VotingEndedMessage : MessageContainer { Guid WinningOption ; Dictionary < Guid , int > VotingResults ; } WinningOption: The GUID of the option that got the most votes from the PlayerAudience. VotingResults: Contains the GUIDs of the option as the key and the respective amount of received votes as the value.","title":"VotingEndedMessage"},{"location":"network-protocol/#control-messages","text":"","title":"Control messages"},{"location":"network-protocol/#errormessage","text":"Specification of a MessageContainer with the type MessageType ::Error . This message is sent from the ServerLogic to the Moderator-Client in case of a disconnection initiated by the ServerLogic and explains the reason for the disconnection. class ErrorMessage : MessageContainer { ErrorType ErrorMessageType ; string ErrorMessageText ; } ErrorMessageType: Specifies the reason for the occurred error. ErrorMessageText: Optional, more detailed description of the occurred error.","title":"ErrorMessage"},{"location":"network-protocol/#requestgamepausedstatuschangemessage","text":"Specification of a MessageContainer with the type MessageType ::RequestGamePausedStatusChange . This message is sent from the Moderator-Client to the ServerLogic to switch the game between running and being paused. class RequestGamePausedStatusChangeMessage : MessageContainer { bool GamePaused ; } GamePaused: Specifies whether the game is to be paused or whether the already paused game is to be continued. With true indicating that the game is to be paused, and false indicating that the game is to be continued. The ServerLogic responds with a GamePauseStatusMessage .","title":"RequestGamePausedStatusChangeMessage"},{"location":"network-protocol/#gamepausestatusmessage","text":"Specification of a MessageContainer with the type MessageType ::GamePausedStatus . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestGamePausedStatusChangeMessage , to confirm that the game is now either continuing or being paused. class GamePauseStatusMessage : MessageContainer { bool GamePaused ; } GamePaused: Specifies whether the game is being paused or whether the already paused game is being continued. With true indicating that the game has been paused, and false indicating that the game is continuing.","title":"GamePauseStatusMessage"},{"location":"network-protocol/#postgame","text":"","title":"Postgame"},{"location":"network-protocol/#requestclosesessionmessage","text":"Specification of a MessageContainer with the type MessageType ::RequestCloseSession . This message is sent from the Moderator-Client to the ServerLogic to tell the ServerLogic to close the Online-Session and with that the connection to the PlayerAudience-Clients. It also commands the ServerLogic to clear the logs. class RequestCloseSessionMessage : MessageContainer { string SessionKey ; } SessionKey: The key of the to be closed Online-Session. The ServerLogic responds with a SessionClosedMessage .","title":"RequestCloseSessionMessage"},{"location":"network-protocol/#sessionclosedmessage","text":"Specification of a MessageContainer with the type MessageType ::SessionClosed . This message is sent from the ServerLogic to the Moderator-Client in response to a RequestCloseSessionMessage , to confirm that the Online-Session has been successfully closed and that the logs have been cleared completely. In addition to that, the statistics of the Online-Session are returned to the Moderator-Client, which can be used to display every conducted vote and which option got how many votes. class SessionClosedMessage : MessageContainer { Dictionary < string , int > Statistics ; } Statistics: Contains the id of the option as the key and the respective amount of received votes as the value.","title":"SessionClosedMessage"},{"location":"network-protocol/#sequence-diagrams-of-typical-communicational-processes","text":"The following diagrams always show typical communication processes between clients and ServerLogic. Only the core contents of the communication, which are relevant for the understanding, are pointed out. For the sake of clarity, the specific message verification mechanisms of the clients and the ServerLogic are not shown, as they are active at all times and check each message for correctness. For example, it is not specifically stated that an IllegalMessage error can be thrown with every message sent or received. Also, detailed procedures that handle multiple processes and deal with errors are not listed here, as these are explicit processes, such as a ReconnectMessage .","title":"Sequence diagrams of typical communicational processes"},{"location":"network-protocol/#start-online-session","text":"This diagram illustrates a typical process from the creation of an online session to the start of the game. It also describes typical errors that can occur when opening the session and optional operations that can be performed by the server and the clients. List of MessageTypes used: RequestOpenSessionMessage , SessionOpenedMessage , AudienceStatusMessage , RequestGameStartMessage , GameStartedMessage , ErrorMessage","title":"Start Online-Session"},{"location":"network-protocol/#player-reconnect","text":"This diagram illustrates a typical process how a Moderator-Client checks if the connection to a ServerLogic has been restored and optionally how the Moderator-Client reconnects to a running session. List of MessageTypes used: RequestServerStatusMessage , ServerStatusMessage , ReconnectMessage , ReconnectSuccessfulMessage","title":"Player reconnect"},{"location":"network-protocol/#pause-game","text":"This diagram illustrates a typical process of how a Moderator-Client initializes a global pause via the ServerLogic. It also describes what happens in the case of an ongoing vote and what typical errors can occur. List of MessageTypes used: RequestGamePausedStatusChangeMessage , GamePauseStatusMessage , ErrorMessage","title":"Pause game"},{"location":"network-protocol/#voting-phase","text":"This diagram illustrates a typical process of how a Moderator-Client initialises an election phase via the ServerLogic and how the PlayerAudience-Clients are involved. List of MessageTypes used: RequestStartVotingMessage , VotingStartedMessage , VotingEndedMessage","title":"Voting phase"},{"location":"network-protocol/#new-moderator","text":"This diagram illustrates a typical process how a Moderator-Client replaces another Moderator-Client while opening a new Online-Session. List of MessageTypes used: RequestOpenSessionMessage , ErrorMessage , SessionOpenedMessage","title":"New moderator"},{"location":"network-protocol/#end-online-session","text":"This diagram illustrates a typical process of how a Moderator-Client ends an existing Online-Session and how the PlayerAudience-Clients are affected. List of MessageTypes used: RequestCloseSessionMessage , SessionClosedMessage","title":"End Online-Session"},{"location":"requirements/","text":"Requirements The requirements are divided into different priorities, whose meaning should be clear from the following table: PRIORITY DESCRIPTION + The requirement must be fulfilled in any case so that the product can be accepted. 0 The fulfillment of the requirement is optional and therefore not necessarily a prerequisite for acceptance, but would have a very positive effect on the product. - The fulfillment of the requirement is also optional and therefore not a prerequisite for the acceptance. Functional requirements This section contains all requirements that specify the basic actions of the software system. Game ID FR1 PRIORITY + DESCRIPTION QualityQuest shall be a 2D RPG. EXPLANATION The PlayerAudience makes decisions over the PlayerCharacter in a fictional, high-fantasy world of a software engineer. The PlayerAudience plays the game only through StoryFlowDecisions, comparable to an interactive film in which the PlayerAudience can actively decide on certain parts of the film. Game presentation ID FR2 PRIORITY + DESCRIPTION QualityQuest shall be a visual-based 2D RPG. EXPLANATION This means that QualityQuest shall not be a purely text-based game, but text may be an element of the visual appearance of the game. NewTec branding ID FR3 PRIORITY + DESCRIPTION QualityQuest shall display the NewTec logo clearly visible at any given time. EXPLANATION - Game language ID FR4 PRIORITY + DESCRIPTION The main language of QualityQuest shall be German. EXPLANATION The majority of the to be used in-game language shall be german, but typical software engineering terms that are not german, but are commonly used in the german language, do not need to be translated. Game language options ID FR5 PRIORITY 0 DESCRIPTION QualityQuest should support multiple languages. EXPLANATION - Music ID FR6 PRIORITY - DESCRIPTION QualityQuest may be accompanied by a suitable musical background to enhance the player experience. EXPLANATION - Sound effects ID FR7 PRIORITY 0 DESCRIPTION QualityQuest should emphasize important events of the StoryFlow with sound effects. EXPLANATION - Game content ID FR8 PRIORITY + DESCRIPTION QualityQuest shall tell a story which mainly consists of typical elements of the software engineering profession. EXPLANATION - StoryFlow ID FR9 PRIORITY + DESCRIPTION The story of QualityQuest shall be non-linear. EXPLANATION The story shall contain elements where the PlayerAudience needs to make a StoryFlowDecision. Depending on the decision, the StoryFlow shall continue in different StoryBranches. Influence on the StoryFlow by the player ID FR10 PRIORITY + DESCRIPTION The PlayerAudience shall influence the selection of StoryBranches by means of StoryFlowDecisions. EXPLANATION - Participation of a larger PlayerAudience ID FR11 PRIORITY + DESCRIPTION QualityQuest shall have the option to let a larger audience participate in StoryFlowDecisions by means of online voting. EXPLANATION The online voting feature is directly embedded into the game, together with an offline backup in case the server can't be used. Random element of StoryFlow control ID FR12 PRIORITY + DESCRIPTION The selection of a StoryBranch after a StoryFlowDecision shall be generated randomly. EXPLANATION Randomness can be either determined through ZeroRandomness or DiceRandomness. Visualizing the randomness ID FR13 PRIORITY + DESCRIPTION If the selection of a StoryBranch after a StoryFlowDecision is generated with DiceRandomness, QualityQuest shall display a clear visualization of the randomization process. EXPLANATION - Character status values ID FR14 PRIORITY + DESCRIPTION The PlayerCharacter shall have all of the following PlayerCharacterStatusValue: Programming, Analytics, Communication, Partying. EXPLANATION - Selecting a character ID FR15 PRIORITY + DESCRIPTION At the start of the game the PlayerAudience shall choose a PlayerCharacter from a selection of 4 possible PlayerCharacters via online voting. EXPLANATION - Presentation of character status values ID FR16 PRIORITY + DESCRIPTION QualityQuest shall display a PlayerCharacterStatusBox with all PlayerCharacterStatusValues at all times. EXPLANATION - Portrait of the PlayerCharacter ID FR17 PRIORITY + DESCRIPTION QualityQuest shall display a portrait of the PlayerCharacter as part of the PlayerCharacterStatusBox all the time. EXPLANATION - Character levelling ID FR18 PRIORITY + DESCRIPTION The PayerCharacter shall level up and level down its PlayerCharacterStatusValues based on events or StoryFlowDecisions. EXPLANATION - Visual presentation of PlayerCharacter status changes ID FR19 PRIORITY + DESCRIPTION The change of PlayerCharacterStatusValues of the PlayerCharacter shall be highlighted visually. EXPLANATION - Acoustic presentation of PlayerCharacter status changes ID FR20 PRIORITY 0 DESCRIPTION The change of PlayerCharacterStatusValues of the PlayerCharacter should be highlighted acoustically. EXPLANATION - Operating system ID FR21 PRIORITY + DESCRIPTION QualityQuest shall run on Microsoft Windows 10 operating system. EXPLANATION - Pause Game ID FR22 PRIORITY + DESCRIPTION The moderator shall have the possibility to pause the game with the PauseButton. EXPLANATION - PauseButton location ID FR23 PRIORITY + DESCRIPTION The PauseButton shall be around the lower right corner. EXPLANATION - Moderator game control ID FR24 PRIORITY + DESCRIPTION Once the Moderator-Client established the connection to the ServerLogic, the moderator shall have the option to start or interrupt the game at any time. EXPLANATION - Connection Timeout ID FR25 PRIORITY + DESCRIPTION If the Moderator-Client does not react within 5 seconds after receiving the ServerLogic's message, the connection from the Moderator-Client to the ServerLogic shall be interrupted. In this case the Moderator can either continue playing in Offline-Mode or try to re-establish the connection to the ServerLogic. EXPLANATION This serves as a failsafe, in case of corrupted messages or connection loss. ServerLogic connection loss ID FR26 PRIORITY + DESCRIPTION If a Moderator-Client or PlayerAudience-Client loses its connection to the ServerLogic, its GUID shall be stored in the ServerLogic. In this case, the respective client can reconnect to the ServerLogic to participate in the game again. EXPLANATION - Data exchange file format ID FR27 PRIORITY + DESCRIPTION The file format for data exchange between Moderator-Client and ServerLogic shall be JSON. EXPLANATION - PlayerAudience-Client GUID ID FR28 PRIORITY + DESCRIPTION Every PlayerAudience-Client shall be assigned a GUID in the form of a web-cookie. EXPLANATION This ensures the following points: Participants can rejoin the game after leaving the game or losing the connection to the ServerLogic. The ServerLogic can ensure a PlayerAudience-Client can't vote several times per vote. The ServerLogic can count the amount of PlayerAudience-Clients connected. Offline-Mode ID FR29 PRIORITY + DESCRIPTION If any of the following conditions apply: The server is not functional The network infrastructure slows down significantly The connection between Moderator-Client and Server is problematic the Moderator shall continue the game offline. EXPLANATION - Offline-Mode transition ID FR30 PRIORITY + DESCRIPTION The Offline-Mode must ensure a smooth transition between online and offline and shall be able to step in at any time. EXPLANATION - Network protocol violation ID FR31 PRIORITY + DESCRIPTION If a client does not adhere to the network protocol 3 times, the GUID of the participant should be excluded from the rest of the game. EXPLANATION This ensures that it is not easily possible to tinker with the game through an altered client. Unique voting option identifier ID FR32 PRIORITY + DESCRIPTION Every voting option shall be assigned a unique voting option identifier by assigning a GUID to every option. EXPLANATION - Game-relevant ServerLogic logging ID FR33 PRIORITY + DESCRIPTION Data that is needed for the general course of the game or for communication between clients and server shall be logged by the ServerLogic. EXPLANATION Relevant data is: The Moderator-Client GUID PlayerAudience-Client GUIDs Online-Session key Vote results General ServerLogic logging ID FR34 PRIORITY + DESCRIPTION The most important and communication relevant operations of the ServerLogic shall be logged on the server side for debugging reasons. EXPLANATION The general data logged by the ServerLogic is neither integral nor personal user data. ServerLogic log deletion ID FR35 PRIORITY + DESCRIPTION Game-relevant logs shall be cleared under following circumstances: No Moderator-Client has been connected to the ServerLogic in the last 30 minutes. A new Online-Session is being started. An ongoing Online-Session is being closed. EXPLANATION This ensures that no user-specific data is being saved on server side longer than it has to be. ServerLogic access-password ID FR36 PRIORITY + DESCRIPTION The ServerLogic shall require a password to connect to it through a Moderator-Client. EXPLANATION - Encryption of integral data ID FR37 PRIORITY + DESCRIPTION Integral data shall be hashed and salted on the server side. EXPLANATION An example for integral data is, but is not limited to being, the ServerLogic access-password. Online-Mode ID FR38 PRIORITY + DESCRIPTION If the Moderator-Client is connected to a server, and the moderator is not currently playing in Offline-Mode, the game shall be in Online-Mode. EXPLANATION - Online-Mode flag ID FR39 PRIORITY + DESCRIPTION A flag shall be set at the initialization of the game to distinguish between a pure Offline-Session, and an Online-Session that can switch between Offline-Mode and Online-Mode. EXPLANATION For network protocol purposes, a flag is set to distinguish whether the game was initialized in Online-Mode or Offline-Mode, so that sending and receiving messages is disregarded right from the start of the game. Moderator-Client GUID ID FR40 PRIORITY + DESCRIPTION The Moderator-Client shall be assigned a GUID by the ServerLogic. EXPLANATION The GUID serves to identify as the Moderator-Client during on-going communication with the ServerLogic. PlayerAudience-Client count ID FR41 PRIORITY 0 DESCRIPTION The ServerLogic should keep count of the number of PlayerAudience-Clients being connected to the ServerLogic. EXPLANATION - PlayerAudience-Client count live update ID FR42 PRIORITY 0 DESCRIPTION The ServerLogic should inform the Moderator-Client in 3 seconds intervals about the amount of PlayerAudience-Clients connected to the ServerLogic, as long as the game didn't start yet. EXPLANATION - Online-Session permanence ID FR43 PRIORITY + DESCRIPTION An Online-Session shall persist until one of the following conditions apply: A new Moderator-Client connects to the ServerLogic. A new Online-Session is started by the moderator. No Moderator-Client has been connected to the ServerLogic in the last 30 minutes. EXPLANATION - Switch between Moderator-Clients ID FR44 PRIORITY + DESCRIPTION If a Moderator-Client connects to the ServerLogic while another Moderator-Client is already connected to the ServerLogic, then the old Moderator-Client shall be kicked and the new Moderator-Client shall stay connected. EXPLANATION - Voting-Timer stop on pause ID FR45 PRIORITY + DESCRIPTION The Voting-Timer shall pause when the Moderator-Client initializes a pause. EXPLANATION - Communication during pauses ID FR46 PRIORITY + DESCRIPTION Communication between Moderator-Client and ServerLogic, and between PlayerAudience-Clients and ServerLogic shall persist during the pause. EXPLANATION - PlayerAudience connection method ID FR47 PRIORITY + DESCRIPTION The PlayerAudience shall be able to join an Online-Session using a dynamically generated session key, provided by the ServerLogic. EXPLANATION - PlayerAudience connection option ID FR48 PRIORITY + DESCRIPTION The PlayerAudience shall be provided with an URL, at the start of the Online-Session, to be able to connect to the ServerLogic. EXPLANATION - Additional PlayerAudience connection options ID FR49 PRIORITY 0 DESCRIPTION The PlayerAudience should also be provided with a QR code, at the start of the Online-Session, to be able to connect to the ServerLogic. EXPLANATION - Pause menu ID FR50 PRIORITY + DESCRIPTION The pause menu shall pop-up after a pause has been initialized. EXPLANATION - Pause menu contents ID FR51 PRIORITY 0 DESCRIPTION The pause menu should display the following elements: A banner that reads \"Paused\" A button to unpause the game The PlayerAudience connection method All PlayerAudience connection options EXPLANATION - Vote indexing procedure ID FR52 PRIORITY + DESCRIPTION The procedure used for indexing the different voting options shall be GUIDs. EXPLANATION - Cryptographic hashing procedure ID FR53 PRIORITY + DESCRIPTION The hashing procedure used for cryptographic purposes shall be SHA-256. EXPLANATION - SessionKey length ID FR54 PRIORITY + DESCRIPTION The SessionKey shall have a size/length of six. EXPLANATION For example: F8G21Z or 8IB2P4 Non-functional Requirements This section specifies the non-functional requirements for the software system. Documents to be delivered ID NFR1 PRIORITY + DESCRIPTION A System Specification, which comprises use case diagrams, use case descriptions and a static view of the software architecture and Software Design Specification for each software component, which describes both the static and the dynamic view shall be delivered. EXPLANATION - In-code documentation style ID NFR2 PRIORITY + DESCRIPTION The source code shall be documented by means of XML comment documentation generation provided by Visual Studio 2019. EXPLANATION - In-code documentation content ID NFR3 PRIORITY + DESCRIPTION All of the following source code elements shall be documented: Constants, variables and defines. Classes and class members. Methods and method signatures, including return values. Functions and function signatures, including return values. EXPLANATION - Documentation style for diagrams ID NFR4 PRIORITY + DESCRIPTION All documentation diagrams shall follow the UML standard. EXPLANATION - Delivery of UML diagrams ID NFR5 PRIORITY + DESCRIPTION All UML diagrams shall be delivered in the form of a diagram and a PlantUML link. EXPLANATION - Adherence to project Coding Styleguide ID NFR6 PRIORITY 0 DESCRIPTION The software code should adhere to the code quality rules and .NET API usage rules Microsoft recommends. EXPLANATION - Adherence to Clean Code Principles ID NFR7 PRIORITY + DESCRIPTION The software code shall adhere to Grade 1 (Red) of the Clean Code Principles. EXPLANATION - Target audience ID NFR8 PRIORITY + DESCRIPTION QualityQuest shall address a target audience of university students with interest in a SW engineering career. EXPLANATION - Playing time ID NFR9 PRIORITY + DESCRIPTION The complete story of QualityQuest shall be playable in a time frame of 15 to 20 minutes. EXPLANATION - Playing fun ID NFR10 PRIORITY 0 DESCRIPTION The story of QualityQuest should be humorous. EXPLANATION - Player motivation ID NFR11 PRIORITY + DESCRIPTION The audience of QualityQuest shall be encouraged to follow the story by motivational elements. EXPLANATION Motivational elements could be for example rewards, achievement & level upgrades. Deliverable artefacts ID NFR12 PRIORITY + DESCRIPTION Documentation, Source Code and a running version of QualityQuest shall be delivered to NewTec. EXPLANATION - Type of delivery ID NFR13 PRIORITY + DESCRIPTION All deliverable artifacts shall be delivered digitally. EXPLANATION The delivery can be by depositing the deliverable artefacts in a public version control system. Documents should be delivered in both PDF and HTML/CSS. Deadline ID NFR14 PRIORITY + DESCRIPTION The deadline for the final delivery is 2021-04-28. EXPLANATION - Open source development ID NFR15 PRIORITY - DESCRIPTION The Source Code of QualityQuest may be published open source under CreativeCommons CC BY-NC 4.0 license terms. EXPLANATION - Stand-alone game ID NFR16 PRIORITY + DESCRIPTION QualityQuest shall be a stand-alone game. EXPLANATION The final binaries shall include everything that is needed to run the game. Any possibly needed frameworks have to be included in the delivery. The installation of additional frameworks or libraries is not acceptable. Programming language ID NFR17 PRIORITY + DESCRIPTION QualityQuest shall be programmed in a C dialect (C, C++ or C#). EXPLANATION - Development environment ID NFR18 PRIORITY + DESCRIPTION Both the source code and the build solution of QualityQuest shall be buildable in one of the following development environments: Microsoft Visual Studio 2019, Microsoft Visual Studio Code. EXPLANATION - Usage of online voting solutions ID NFR19 PRIORITY - DESCRIPTION A self-made online voting solution shall be created by the team in order to implement the requirements of the tool and ensure the compatibility as optimal as possible. EXPLANATION - Amount of supported connections ID NFR20 PRIORITY + DESCRIPTION The Server shall allow up to 200 PlayerAudience-Clients to connect to the game via the network. EXPLANATION - Exclusive Moderator-Client connection ID NFR21 PRIORITY + DESCRIPTION The ServerLogic shall only allow a single Moderator-Client to connect to the ServerLogic at any given time. EXPLANATION - Game Engine ID NFR22 PRIORITY + DESCRIPTION As a game engine the project shall use Unity. EXPLANATION The license conditions of the game engine allow the source code of QualityQuest to be open source. The license conditions of the game engine allow the usage of the game engine without license fees. The license conditions of the game engine allow the usage of QualityQuest as intended by NewTec without license fees. Communication security ID NFR23 PRIORITY + DESCRIPTION The safe communication between Moderator-Client and the ServerLogic shall be guaranteed through WebSocket and HTTPS. EXPLANATION - Postgame statistics ID NFR24 PRIORITY 0 DESCRIPTION The Moderator-Client should display postgame statistics at the end of the Online-Session. EXPLANATION - Postgame statistic contents ID NFR25 PRIORITY 0 DESCRIPTION The postgame statistics should display which option was voted how often. EXPLANATION -","title":"Requirements"},{"location":"requirements/#requirements","text":"The requirements are divided into different priorities, whose meaning should be clear from the following table: PRIORITY DESCRIPTION + The requirement must be fulfilled in any case so that the product can be accepted. 0 The fulfillment of the requirement is optional and therefore not necessarily a prerequisite for acceptance, but would have a very positive effect on the product. - The fulfillment of the requirement is also optional and therefore not a prerequisite for the acceptance.","title":"Requirements"},{"location":"requirements/#functional-requirements","text":"This section contains all requirements that specify the basic actions of the software system.","title":"Functional requirements"},{"location":"requirements/#non-functional-requirements","text":"This section specifies the non-functional requirements for the software system.","title":"Non-functional Requirements"},{"location":"storyflow/","text":"StoryFlow diagram StoryFlow overview A rough overview of the decisions occurring within the StoryGraph. The diagram exclusively depicts the situations in which StoryFlowDecisions can be made and the choices to be made in these situations. Detailed StoryFlow diagrams A detailed overview of the individual StoryFlowDecisions. The diagrams contain all individual situations with every possible StoryFlowDecision and all effects that result by choosing the respective StoryFlowDecision. StoryFlowDecision 1 In this StoryFlowDecision the PlayerAudience decides with which PlayerCharacter they want to play the game. The following PlayerCharacters are available for selection: Noruso Lumati Turgal Kirogh After the PlayerCharacter selection, the next step is selecting the missing subject. StoryFlowDecision 2 The PlayerAudience must choose a subject from the following selection of available subjects: Introduction to Bali Requirements Engineering Introduction to Software Architectures Usability as success factor After finishing the subject, the PlayerCharacter increases their PlayerCharacterStatusValues, depending on which subject was voted for. StoryFlowDecision 3 Now that the PlayerCharacter has finished their subject, the PlayerAudience can decide if the PlayerCharacter should take part in an extracurricular activity, or not. The following options are available: The PlayerCharacter can participate in a hackathon at the university. The PlayerCharacter can use the time to learn a new programming language. The PlayerCharacter does not participate in any extracurricular activity and enjoys their free time and goes partying. The PlayerCharacter has successfully completed their studies. StoryFlowDecision 4 The PlayerCharacter has successfully completed their studies and accepted a job at NewTec GmbH some time after. Which means that the PlayerCharacter now has to complete their first task in a new project. The PlayerAudience decides how the PlayerCharacter will proceed: The PlayerCharacter asks the mentor for advice. The PlayerCharacter looks for a suitable solution on HeapOverflow. The PlayerCharacter simply starts working. The PlayerCharacterStatusValues of the PlayerCharacter change according to the selected StoryFlowDecision and after the task has been completed, the next StoryFlowDecision is about the corresponding tests. StoryFlowDecision 5 The first task has been completed, the next StoryFlowDecisions is about the corresponding tests. The PlayerCharacter has only a certain amount of time until the tests have to be finished, and the PlayerAudience has to decide how the PlayerCharacter should proceed. The following options are available: The PlayerCharacter writes the tests until they are ready, regardless of the deadline. The PlayerCharacter writes the tests until the deadline is reached. The outcome of the StoryFlowDecision is also influenced by DiceRandomness. Depending on the StoryFlowDecision and some luck the PlayerCharacterStatusValues level up or down. After the tests are completed, a company party is scheduled, and the decision whether the player character will participate or not is part of the next StoryFlowDecision. StoryFlowDecision 6 The PlayerAudience can decide in the next StoryFlowDecision whether the PlayerCharacter will participate in the company party or not. The following options are available: The PlayerCharacter attends the company party. The PlayerCharacter does not take part in the party, but continues working on the project. If the PlayerCharacter goes to the party, the PlayerAudience must decide in the next StoryFlowDecisions how the PlayerCharacter behaves on the party. If the PlayerCharacter does not attend the party, the next StoryFlowDecision is about possibly participating in a voluntary training course. StoryFlowDecision 7 The PlayerAudience can now decide what the PlayerCharacter does first on the party: The PlayerCharacter talks with colleagues. The PlayerCharacter talks with the mentor and the boss. The PlayerCharacter sits alone on one seat. Depending on the StoryFlowDecision, the PlayerCharacter increases their PlayerCharacterStatusValues or the PlayerAudience enables additional dialog options for later StoryFlowDecisions. StoryFlowDecision 8 The PlayerCharacter is still at the party and is thirsty. The PlayerAudience decides what the PlayerCharacter will drink: One beer One coke Two Tequila shots. This decision triggers another StoryFlowDecision, the PlayerAudience needs to decide if the PlayerCharacter wants to drink more after the first two shots of Tequila: The PlayerCharacters keeps drinking more shots. The PlayerCharacter stops after the first two shots. If the PlayerAudience decides to drink beer or coke, the evening ends quietly. If the PlayerAudience decides to drink hard liquor, the party may instead end badly, resulting in the PlayerCharacter losing PlayerCharacterStatusValues due to getting severely drunk and ruining the event. Eventually the party ends and the PlayerCharacter goes home. The next StoryFlowDecision is about the participation in a voluntary training course. StoryFlowDecision 9 The PlayerAudience can now decide if the PlayerCharacter takes part in a voluntary training course. The following options are available: Yes, the PlayerCharacter participates. The PlayerCharacter does not participate. The PlayerCharacter takes a vacation. Additional dialog option: The boss of the PlayerCharacter offers one week of vacation after the voluntary training course. Depending on the StoryFlowDecision, there may be a deadline delay and an increase or decrease of the PlayerCharacterStatusValues. After the voluntary training course is over, the customer calls because they want to make changes to the product. The PlayerAudience decides how to proceed in the next StoryFlowDecision. StoryFlowDecision 10 The customer explains on the phone what they want changed, after which the PlayerAudience can decide how the PlayerCharacter proceeds: The PlayerCharacter simply hangs up. The PlayerCharacter implements the change directly. The PlayerCharacter notices that the change is technically not easy to implement. This decision triggers another StoryFlowDecision: The PlayerCharacter informs the customer. The PlayerCharacter does not inform the customer. The PlayerCharacterStatusValues change depending on the StoryFlowDecision made by the PlayerAudience. With the occurrence of a new bug, the PlayerAudience has to decide how the PlayerCharacter will handle the issue in the next StoryFlowDecision. StoryFlowDecision 11 A new bug has surfaced that nobody has found yet. The PlayerAudience can choose from the following options: The PlayerCharacter writes a bug ticket. The PlayerCharacter ignores the bug. If the PlayerAudience decides to ignore the bug, the bug might be noticed by other developers with a certain DiceRandomness. In the case that the bug is detected, the PlayerCharacterStatusValues decrease drastically, but if the bug remains undetected the PlayerCharacterStatusValues only decrease slightly. Reporting the bug instead increased the PlayerCharacterStatusValues of the PlayerCharacter. In the next StoryFlowDecision the customer calls again, because they want an additional feature implemented. StoryFlowDecision 12 The customer explains the new feature on the phone, after which the PlayerAudience must decide how the PlayerCharacter proceeds: The PlayerCharacter starts to implement the feature. The PlayerCharacter asks the customer if he really wants the feature. This decision triggers another StoryFlowDecision. The customer wants to go through the change process with their new feature idea. The PlayerAudience can choose from the following options: The PlayerCharacter implements the feature together with the customer. The PlayerCharacter sets a meeting with req. engineer, usability and test manager. The feature is implemented and depending on the StoryFlowDecision, the PlayerCharacterStatusValues change. In the next StoryFlowDecision the PlayerAudience has to decide if the PlayerCharacter helps out a colleague or not. StoryFlowDecision 13 A colleague approaches the PlayerCharacter and asks for help with a task. The PlayerAudience can choose from the following options: The PlayerCharacter helps the colleague. This decision triggers another StoryFlowDecision, since the PlayerCharacter cant meet their own deadline: The PlayerCharacter asks another colleague for help on their own task. The PlayerCharacter works alone on their task. The PlayerCharacter keeps working on their own task. Depending on the decision, the PlayerCharacterStatusValues change, while DiceRandomness may also cause additional deadline delays. The project is nearing completion, the next StoryFlowDecision will be about how to handle a code review. StoryFlowDecision 14 The PlayerAudience must decide whether the PlayerCharacter takes part in a code review. The following options are available: The PlayerCharacter participates in the review. The PlayerCharacter does not participate in the review. If the PlayerCharacter participates in the review, the PlayerCharacterStatusValues increase, otherwise they decrease. The project has been completed. StoryFlowDecision 15 A workshop in Hawaii is on the agenda. All PlayerCharacterStatusValues will be summed up and depending on the sum there are following options: The PlayerCharacter can participate in the workshop. The PlayerCharacter is not allowed to participate in the workshop. The PlayerCharacter gets fired. The game was successfully played through.","title":"StoryFlow"},{"location":"storyflow/#storyflow-diagram","text":"","title":"StoryFlow diagram"},{"location":"storyflow/#storyflow-overview","text":"A rough overview of the decisions occurring within the StoryGraph. The diagram exclusively depicts the situations in which StoryFlowDecisions can be made and the choices to be made in these situations.","title":"StoryFlow overview"},{"location":"storyflow/#detailed-storyflow-diagrams","text":"A detailed overview of the individual StoryFlowDecisions. The diagrams contain all individual situations with every possible StoryFlowDecision and all effects that result by choosing the respective StoryFlowDecision.","title":"Detailed StoryFlow diagrams"},{"location":"storyflow/#storyflowdecision-1","text":"In this StoryFlowDecision the PlayerAudience decides with which PlayerCharacter they want to play the game. The following PlayerCharacters are available for selection: Noruso Lumati Turgal Kirogh After the PlayerCharacter selection, the next step is selecting the missing subject.","title":"StoryFlowDecision 1"},{"location":"storyflow/#storyflowdecision-2","text":"The PlayerAudience must choose a subject from the following selection of available subjects: Introduction to Bali Requirements Engineering Introduction to Software Architectures Usability as success factor After finishing the subject, the PlayerCharacter increases their PlayerCharacterStatusValues, depending on which subject was voted for.","title":"StoryFlowDecision 2"},{"location":"storyflow/#storyflowdecision-3","text":"Now that the PlayerCharacter has finished their subject, the PlayerAudience can decide if the PlayerCharacter should take part in an extracurricular activity, or not. The following options are available: The PlayerCharacter can participate in a hackathon at the university. The PlayerCharacter can use the time to learn a new programming language. The PlayerCharacter does not participate in any extracurricular activity and enjoys their free time and goes partying. The PlayerCharacter has successfully completed their studies.","title":"StoryFlowDecision 3"},{"location":"storyflow/#storyflowdecision-4","text":"The PlayerCharacter has successfully completed their studies and accepted a job at NewTec GmbH some time after. Which means that the PlayerCharacter now has to complete their first task in a new project. The PlayerAudience decides how the PlayerCharacter will proceed: The PlayerCharacter asks the mentor for advice. The PlayerCharacter looks for a suitable solution on HeapOverflow. The PlayerCharacter simply starts working. The PlayerCharacterStatusValues of the PlayerCharacter change according to the selected StoryFlowDecision and after the task has been completed, the next StoryFlowDecision is about the corresponding tests.","title":"StoryFlowDecision 4"},{"location":"storyflow/#storyflowdecision-5","text":"The first task has been completed, the next StoryFlowDecisions is about the corresponding tests. The PlayerCharacter has only a certain amount of time until the tests have to be finished, and the PlayerAudience has to decide how the PlayerCharacter should proceed. The following options are available: The PlayerCharacter writes the tests until they are ready, regardless of the deadline. The PlayerCharacter writes the tests until the deadline is reached. The outcome of the StoryFlowDecision is also influenced by DiceRandomness. Depending on the StoryFlowDecision and some luck the PlayerCharacterStatusValues level up or down. After the tests are completed, a company party is scheduled, and the decision whether the player character will participate or not is part of the next StoryFlowDecision.","title":"StoryFlowDecision 5"},{"location":"storyflow/#storyflowdecision-6","text":"The PlayerAudience can decide in the next StoryFlowDecision whether the PlayerCharacter will participate in the company party or not. The following options are available: The PlayerCharacter attends the company party. The PlayerCharacter does not take part in the party, but continues working on the project. If the PlayerCharacter goes to the party, the PlayerAudience must decide in the next StoryFlowDecisions how the PlayerCharacter behaves on the party. If the PlayerCharacter does not attend the party, the next StoryFlowDecision is about possibly participating in a voluntary training course.","title":"StoryFlowDecision 6"},{"location":"storyflow/#storyflowdecision-7","text":"The PlayerAudience can now decide what the PlayerCharacter does first on the party: The PlayerCharacter talks with colleagues. The PlayerCharacter talks with the mentor and the boss. The PlayerCharacter sits alone on one seat. Depending on the StoryFlowDecision, the PlayerCharacter increases their PlayerCharacterStatusValues or the PlayerAudience enables additional dialog options for later StoryFlowDecisions.","title":"StoryFlowDecision 7"},{"location":"storyflow/#storyflowdecision-8","text":"The PlayerCharacter is still at the party and is thirsty. The PlayerAudience decides what the PlayerCharacter will drink: One beer One coke Two Tequila shots. This decision triggers another StoryFlowDecision, the PlayerAudience needs to decide if the PlayerCharacter wants to drink more after the first two shots of Tequila: The PlayerCharacters keeps drinking more shots. The PlayerCharacter stops after the first two shots. If the PlayerAudience decides to drink beer or coke, the evening ends quietly. If the PlayerAudience decides to drink hard liquor, the party may instead end badly, resulting in the PlayerCharacter losing PlayerCharacterStatusValues due to getting severely drunk and ruining the event. Eventually the party ends and the PlayerCharacter goes home. The next StoryFlowDecision is about the participation in a voluntary training course.","title":"StoryFlowDecision 8"},{"location":"storyflow/#storyflowdecision-9","text":"The PlayerAudience can now decide if the PlayerCharacter takes part in a voluntary training course. The following options are available: Yes, the PlayerCharacter participates. The PlayerCharacter does not participate. The PlayerCharacter takes a vacation. Additional dialog option: The boss of the PlayerCharacter offers one week of vacation after the voluntary training course. Depending on the StoryFlowDecision, there may be a deadline delay and an increase or decrease of the PlayerCharacterStatusValues. After the voluntary training course is over, the customer calls because they want to make changes to the product. The PlayerAudience decides how to proceed in the next StoryFlowDecision.","title":"StoryFlowDecision 9"},{"location":"storyflow/#storyflowdecision-10","text":"The customer explains on the phone what they want changed, after which the PlayerAudience can decide how the PlayerCharacter proceeds: The PlayerCharacter simply hangs up. The PlayerCharacter implements the change directly. The PlayerCharacter notices that the change is technically not easy to implement. This decision triggers another StoryFlowDecision: The PlayerCharacter informs the customer. The PlayerCharacter does not inform the customer. The PlayerCharacterStatusValues change depending on the StoryFlowDecision made by the PlayerAudience. With the occurrence of a new bug, the PlayerAudience has to decide how the PlayerCharacter will handle the issue in the next StoryFlowDecision.","title":"StoryFlowDecision 10"},{"location":"storyflow/#storyflowdecision-11","text":"A new bug has surfaced that nobody has found yet. The PlayerAudience can choose from the following options: The PlayerCharacter writes a bug ticket. The PlayerCharacter ignores the bug. If the PlayerAudience decides to ignore the bug, the bug might be noticed by other developers with a certain DiceRandomness. In the case that the bug is detected, the PlayerCharacterStatusValues decrease drastically, but if the bug remains undetected the PlayerCharacterStatusValues only decrease slightly. Reporting the bug instead increased the PlayerCharacterStatusValues of the PlayerCharacter. In the next StoryFlowDecision the customer calls again, because they want an additional feature implemented.","title":"StoryFlowDecision 11"},{"location":"storyflow/#storyflowdecision-12","text":"The customer explains the new feature on the phone, after which the PlayerAudience must decide how the PlayerCharacter proceeds: The PlayerCharacter starts to implement the feature. The PlayerCharacter asks the customer if he really wants the feature. This decision triggers another StoryFlowDecision. The customer wants to go through the change process with their new feature idea. The PlayerAudience can choose from the following options: The PlayerCharacter implements the feature together with the customer. The PlayerCharacter sets a meeting with req. engineer, usability and test manager. The feature is implemented and depending on the StoryFlowDecision, the PlayerCharacterStatusValues change. In the next StoryFlowDecision the PlayerAudience has to decide if the PlayerCharacter helps out a colleague or not.","title":"StoryFlowDecision 12"},{"location":"storyflow/#storyflowdecision-13","text":"A colleague approaches the PlayerCharacter and asks for help with a task. The PlayerAudience can choose from the following options: The PlayerCharacter helps the colleague. This decision triggers another StoryFlowDecision, since the PlayerCharacter cant meet their own deadline: The PlayerCharacter asks another colleague for help on their own task. The PlayerCharacter works alone on their task. The PlayerCharacter keeps working on their own task. Depending on the decision, the PlayerCharacterStatusValues change, while DiceRandomness may also cause additional deadline delays. The project is nearing completion, the next StoryFlowDecision will be about how to handle a code review.","title":"StoryFlowDecision 13"},{"location":"storyflow/#storyflowdecision-14","text":"The PlayerAudience must decide whether the PlayerCharacter takes part in a code review. The following options are available: The PlayerCharacter participates in the review. The PlayerCharacter does not participate in the review. If the PlayerCharacter participates in the review, the PlayerCharacterStatusValues increase, otherwise they decrease. The project has been completed.","title":"StoryFlowDecision 14"},{"location":"storyflow/#storyflowdecision-15","text":"A workshop in Hawaii is on the agenda. All PlayerCharacterStatusValues will be summed up and depending on the sum there are following options: The PlayerCharacter can participate in the workshop. The PlayerCharacter is not allowed to participate in the workshop. The PlayerCharacter gets fired. The game was successfully played through.","title":"StoryFlowDecision 15"},{"location":"toc/","text":"Table of contents Quality Quest Introduction Motivation Vision Context of project Table of contents Glossary Actors and roles Expertise Requirements Functional requirements Non-functional requirements Use-Cases PlayerAudience-Client Server Moderator-Client Architecture design Component diagrams Class diagrams Network protocol General information ServerLogic logs MessageContainer MessageType Enum Who can send which MessageType? ErrorType Enum Detailed message definitions Sequence diagrams StoryFlow StoryFlow overview Detailed StoryFlow diagrams Used tools, plugins and libraries Used tools Used plugins Used libraries Change history","title":"Table of content"},{"location":"toc/#table-of-contents","text":"Quality Quest Introduction Motivation Vision Context of project Table of contents Glossary Actors and roles Expertise Requirements Functional requirements Non-functional requirements Use-Cases PlayerAudience-Client Server Moderator-Client Architecture design Component diagrams Class diagrams Network protocol General information ServerLogic logs MessageContainer MessageType Enum Who can send which MessageType? ErrorType Enum Detailed message definitions Sequence diagrams StoryFlow StoryFlow overview Detailed StoryFlow diagrams Used tools, plugins and libraries Used tools Used plugins Used libraries Change history","title":"Table of contents"},{"location":"use-case-diagrams/","text":"Use-case diagrams PlayerAudience-Client Via the PlayerAudience-Client, the individual participant, as part of the PlayerAudience, has the possibility to vote on the StoryFlowDecisions that occur in the game. The PlayerAudience-Client also acts as an actor for the ServerLogic. ServerLogic The SevrerLogic receives the respective StoryFlowDecisions from the PlayerAudience-Client, collects them and evaluates them in relation to the number of votes. The ServerLogic also acts as an actor for the Moderator-Client. Moderator-Client Start application To start the game the Moderator-Client has to be launched by the moderator first. During the start of the application a flash screen with the NewTec logo is shown after which the main menu is loaded- In the main menu, a connection to the ServerLogic must first be established to start an Online-Session. If a connection has been established the game can be started through the menu. Alternatively there is the option to start the game in Offline-Mode in case no connection to the ServerLogic can be established or online voting is not needed. In the main menu an option sub-menu allows the moderator to set options like volume, resolution and language. The main menu also allows the moderator to close the game. Play game If there is an Online-Session to the ServerLogic, the ServerLogic gathers data from the PlayerAudience and tells the Moderator-Client what has to be done depending on the data collected. The moderator can pause the game locally, which simultaneously sends a message to the ServerLogic to stop the voting process on the ServerLogic side. If there is no Online-Session, the moderator plays the game in form of a Offline-Session. End application The moderator is responsible for ending the application. When the moderator ends the application, and an Online-Session is in progress, a message is sent to the ServerLogic to end the current Online-Session with the PlayerAudience-Clients.","title":"Use-Cases"},{"location":"use-case-diagrams/#use-case-diagrams","text":"","title":"Use-case diagrams"},{"location":"use-case-diagrams/#playeraudience-client","text":"Via the PlayerAudience-Client, the individual participant, as part of the PlayerAudience, has the possibility to vote on the StoryFlowDecisions that occur in the game. The PlayerAudience-Client also acts as an actor for the ServerLogic.","title":"PlayerAudience-Client"},{"location":"use-case-diagrams/#serverlogic","text":"The SevrerLogic receives the respective StoryFlowDecisions from the PlayerAudience-Client, collects them and evaluates them in relation to the number of votes. The ServerLogic also acts as an actor for the Moderator-Client.","title":"ServerLogic"},{"location":"use-case-diagrams/#moderator-client","text":"","title":"Moderator-Client"},{"location":"use-case-diagrams/#start-application","text":"To start the game the Moderator-Client has to be launched by the moderator first. During the start of the application a flash screen with the NewTec logo is shown after which the main menu is loaded- In the main menu, a connection to the ServerLogic must first be established to start an Online-Session. If a connection has been established the game can be started through the menu. Alternatively there is the option to start the game in Offline-Mode in case no connection to the ServerLogic can be established or online voting is not needed. In the main menu an option sub-menu allows the moderator to set options like volume, resolution and language. The main menu also allows the moderator to close the game.","title":"Start application"},{"location":"use-case-diagrams/#play-game","text":"If there is an Online-Session to the ServerLogic, the ServerLogic gathers data from the PlayerAudience and tells the Moderator-Client what has to be done depending on the data collected. The moderator can pause the game locally, which simultaneously sends a message to the ServerLogic to stop the voting process on the ServerLogic side. If there is no Online-Session, the moderator plays the game in form of a Offline-Session.","title":"Play game"},{"location":"use-case-diagrams/#end-application","text":"The moderator is responsible for ending the application. When the moderator ends the application, and an Online-Session is in progress, a message is sent to the ServerLogic to end the current Online-Session with the PlayerAudience-Clients.","title":"End application"},{"location":"usedtools/","text":"Used tools, plugins and libraries A list of all tools, plugins and libraries that have been used to create the documentation of the product and helped implementing Quality Quest. The list contains the name of the respective tool, the version that has been used (or a link to the webpage) and a description on how the tool was used. Used tools The following tools were used during the creation of Quality Quest and the documentation: Tool Description Version Visual Studio Code Tool to create and edit markdown files, and also to create and edit PlantUML files. 1.49 Visual Studio 2019 Tool to create and edit any files associated with a C# software project. 16.8.2 PlantUML Used to create the required UML diagrams.. 1.2020.15 GIMP Editor for raster graphics. Was used for image editing. 2.10.18 SourceTree GUI for git. 4.0.1 GitKraken GUI for git. 5.0.4 MkDocs Documentation tool for creating stylized documentation through markdown files. 1.1.2 GitHub Tool for source code management and version control. link Doxygen Tool to generate software reference documentation. 1.8.20 Aseprite Tool to create pixelart sprites and animations. 1.2.25 Planttext A website for converting PlantUML files into svg files. link Docker Tool used to use other tools directly without the need of installing anything, 19.03.13 m2r Markdown to reStructuredText converter used for making the docs usable for Sphinx. link Sphinx Documentation tool for creating stylized documentation through reStructuredText. 3.2.1 Adobe XD Adobe XD is a vector-based user experience design tool for web apps and mobile apps. 34.0 Used plugins The following plugins were used during the creation of Quality Quest and the documentation: Plugin Description Version Markdown All in One Visual Studio Code plugin used for creating MkDocs easier. 3.3.0 PlantUML Visual Studio Code plugin used for creating PlantUML diagrams directly in VSC and to see the diagram live-update. 2.13.13 mkdocs-with-pdf MkDocs plugin used for creating a PDF out of the MkDocs documents. 0.7.5 Admonition MkDocs extension used to create admonitions in the documentation. link Live Share Visual Studio (Code) plugin used for collaboratively editing any codebase with others in real time. v1.0.3046 Code Spell Checker Visual Studio Code plugin used for spell checking source code. 1.9.0 Used libraries The following libraries were used during the creation of Quality Quest: Library Description Version Microsoft.NET.Test.Sdk The MSbuild targets and properties for building .NET test projects. 16.8.3 MSTest.TestAdapter The adapter to discover and execute MSTest Framework based tests. 2.1.2 MSTest.TestFramework This is MSTest V2, the evolution of Microsoft's Test Framework. 2.1.2 System.Drawing.Common Provides access to GDI+ graphics functionality. 5.0.0 QRCoder QRCoder is a simple library, written in C#.NET, which enables you to create QR codes. 1.4.1 coverlet.collector Coverlet is a cross platform code coverage library for .NET, with support for line, branch and method coverage. 1.3.0","title":"Used tools, plugins and libraries"},{"location":"usedtools/#used-tools-plugins-and-libraries","text":"A list of all tools, plugins and libraries that have been used to create the documentation of the product and helped implementing Quality Quest. The list contains the name of the respective tool, the version that has been used (or a link to the webpage) and a description on how the tool was used.","title":"Used tools, plugins and libraries"},{"location":"usedtools/#used-tools","text":"The following tools were used during the creation of Quality Quest and the documentation: Tool Description Version Visual Studio Code Tool to create and edit markdown files, and also to create and edit PlantUML files. 1.49 Visual Studio 2019 Tool to create and edit any files associated with a C# software project. 16.8.2 PlantUML Used to create the required UML diagrams.. 1.2020.15 GIMP Editor for raster graphics. Was used for image editing. 2.10.18 SourceTree GUI for git. 4.0.1 GitKraken GUI for git. 5.0.4 MkDocs Documentation tool for creating stylized documentation through markdown files. 1.1.2 GitHub Tool for source code management and version control. link Doxygen Tool to generate software reference documentation. 1.8.20 Aseprite Tool to create pixelart sprites and animations. 1.2.25 Planttext A website for converting PlantUML files into svg files. link Docker Tool used to use other tools directly without the need of installing anything, 19.03.13 m2r Markdown to reStructuredText converter used for making the docs usable for Sphinx. link Sphinx Documentation tool for creating stylized documentation through reStructuredText. 3.2.1 Adobe XD Adobe XD is a vector-based user experience design tool for web apps and mobile apps. 34.0","title":"Used tools"},{"location":"usedtools/#used-plugins","text":"The following plugins were used during the creation of Quality Quest and the documentation: Plugin Description Version Markdown All in One Visual Studio Code plugin used for creating MkDocs easier. 3.3.0 PlantUML Visual Studio Code plugin used for creating PlantUML diagrams directly in VSC and to see the diagram live-update. 2.13.13 mkdocs-with-pdf MkDocs plugin used for creating a PDF out of the MkDocs documents. 0.7.5 Admonition MkDocs extension used to create admonitions in the documentation. link Live Share Visual Studio (Code) plugin used for collaboratively editing any codebase with others in real time. v1.0.3046 Code Spell Checker Visual Studio Code plugin used for spell checking source code. 1.9.0","title":"Used plugins"},{"location":"usedtools/#used-libraries","text":"The following libraries were used during the creation of Quality Quest: Library Description Version Microsoft.NET.Test.Sdk The MSbuild targets and properties for building .NET test projects. 16.8.3 MSTest.TestAdapter The adapter to discover and execute MSTest Framework based tests. 2.1.2 MSTest.TestFramework This is MSTest V2, the evolution of Microsoft's Test Framework. 2.1.2 System.Drawing.Common Provides access to GDI+ graphics functionality. 5.0.0 QRCoder QRCoder is a simple library, written in C#.NET, which enables you to create QR codes. 1.4.1 coverlet.collector Coverlet is a cross platform code coverage library for .NET, with support for line, branch and method coverage. 1.3.0","title":"Used libraries"}]}